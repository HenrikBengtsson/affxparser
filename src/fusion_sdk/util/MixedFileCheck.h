////////////////////////////////////////////////////////////////
//
// Copyright (C) 2006 Affymetrix, Inc.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License (version 2) as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program;if not, write to the
//
// Free Software Foundation, Inc.,
// 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
//
////////////////////////////////////////////////////////////////

/**
 * @file   MixedFileCheck.h
 * @brief  Class for testing whether two text files, containing
 * both text and numeric data, are equal, within tolerances
 * for numeric data.
 */
#ifndef MIXEDFILECHECK_H
#define MIXEDFILECHECK_H

#include <fstream>
#include <sstream>
#include <string>

#include "util/Convert.h"
#include "RegressionCheck.h"

/**
 * Class for testing whether two files, containing both text
 * and numeric data, are equal, within tolerances for numeric
 * data, ignoring line endings.
 */
class MixedFileCheck: public RegressionCheck
{
public:
  /**
   * Constructor.
   *
   * @param generatedFile File generated by application.
   * @param goldFile Comparison file, assumed to be correct.
   * @param eps Maximum accepted absolute difference in numeric values.
   * @param skipLines Number of lines to skip.
   * @param allowedMismatch Maximum number of non-matching numeric values accepted.
   */
  MixedFileCheck (const char* generatedFile, const char* goldFile, const double eps,
    const unsigned int skipLines, const unsigned int allowedMismatch)
    : m_GeneratedFile (generatedFile), m_GoldFile (goldFile), m_Eps (eps),
      m_SkipLines (skipLines), m_AllowedMismatch (allowedMismatch)
  {}

  /**
   * Check that the two files are the same, within tolerances.
   *
   * @param errorMsg Error message generated if the test fails.
   * @return bool Return true if files pass tests, else false.
   */
  bool check (std::string& errorMsg)
  {
    // Open files.
    Verbose::out(1,"Reading in file: " + ToStr(m_GoldFile));
    Verbose::out(1,"Reading in file: " + ToStr(m_GeneratedFile));

    std::ifstream generatedStream (m_GeneratedFile);
    if (! generatedStream )
    {
      errorMsg = "Unable to open generated file " + std::string (m_GeneratedFile);
      Verbose::out(1,errorMsg);
      return false;
    }
    std::ifstream goldStream (m_GoldFile);
    if (! goldStream )
    {
      errorMsg = "Unable to open gold file " + std::string (m_GoldFile);
      Verbose::out(1,errorMsg);
      return false;
    }
    unsigned int lineCount = 0;
    unsigned int mismatchCount = 0;
    const char* lineEndings = "\r\n";
    std::string goldLine, generatedLine;
    Verbose::out(1,"Looking for differences.");
    while (! goldStream.eof() && ! goldStream.fail())
    {
      // Skip header lines -- for now
      // really need TsvFileCheck that replaces
      // MixedFileCheck and MatrixFileCheck
      do {
          getline (goldStream, goldLine);
      } while(goldLine[0] == '#');
      do {
        getline (generatedStream, generatedLine);
      } while(generatedLine[0] == '#');
      if (generatedStream.eof() && ! goldStream.eof())
      {
        errorMsg = "The generated file, " + std::string (m_GeneratedFile)
  	+ ", has fewer lines than the gold file, " + std::string (m_GoldFile);
        Verbose::out(1,errorMsg);
        return false;
      }
      // Skip header lines which need not be equal.
      if (++lineCount > m_SkipLines)
      {
        // Avoid line ending hassles.
        goldLine = goldLine.erase (goldLine.find_last_not_of (lineEndings) + 1);
        generatedLine = generatedLine.erase (generatedLine.find_last_not_of (lineEndings) + 1);

	// Skipping white space, convert each line to a series of strings.
	std::istringstream goldStream (goldLine);
	std::istringstream generatedStream (generatedLine);
	std::string goldString, generatedString;
	while (goldStream >> goldString)
	{
	  // Require the same number of whitespace delimited fields.
	  if (! (generatedStream >> generatedString))
	  {
	    errorMsg = lineErrorMsg (generatedLine, goldLine);
        Verbose::out(1,errorMsg);
	    return false;
	  }
	  double goldDouble, generatedDouble;
	  bool goldSuccess, generatedSuccess;
	  goldDouble = Convert::toDoubleCheck (goldString.c_str(), &goldSuccess);
	  generatedDouble = Convert::toDoubleCheck (generatedString.c_str(), &generatedSuccess);

	  // If both fields are numeric, check for equality within the prescribed tolerance.
	  if (goldSuccess && generatedSuccess)
	  {
	    if (fabs (goldDouble - generatedDouble) > m_Eps)
	      ++mismatchCount;
	    continue;
	  }

	  // If neither field is numeric, require them to be identical.
	  if ((! goldSuccess) && (! generatedSuccess) && (goldString == generatedString))
	    continue;

	  // Quit if there is a type mismatch or both fields are non-numeric, not identical.
	  errorMsg = lineErrorMsg (generatedLine, goldLine);
      Verbose::out(1,errorMsg);
	  return false;
	} // end while (goldStream >> goldString)

	// Require that the two lines have the same number of fields.
	if (generatedStream >> generatedString)
	{
	  errorMsg = lineErrorMsg (generatedLine, goldLine);
      Verbose::out(1,errorMsg);
	  return false;
	}
      } // end if (++lineCount > m_SkipLines)
    }   // end while (! goldStream.eof() && ! goldStream.fail())

    // The two files should reach eof at the same time.
    if (! generatedStream.eof())
    {
      errorMsg = "The generated file, " + std::string (m_GeneratedFile)
        + ", has more lines than the gold file, " + std::string (m_GoldFile);
      Verbose::out(1,errorMsg);
      return false;
    }

    // Require that the number of numeric differences above tolerance is below
    // the defined threshold.
    if (mismatchCount > m_AllowedMismatch)
    {
      errorMsg = "There were " + ToStr (mismatchCount) + " instances where "
        + "numeric fields differed by more than the accepted tolerance: only "
        + ToStr (m_AllowedMismatch) + " are allowed";
      Verbose::out(1,errorMsg);
      return false;
    }

    Verbose::out(1,"Same.");
    return true;
  }

private:
  /**
   * Generate a generic error message for a line mismatch.
   *
   * @param generatedLine Line generated by the application.
   * @param goldLine Line considered to be correct.
   * @return Error message.
   */
  const std::string lineErrorMsg (const std::string& generatedLine, const std::string& goldLine)
  {
    const std::string msg = "Mismatch reading generated file " + std::string (m_GeneratedFile)
      + ":\ngold line: '" + goldLine + "'\ngenerated line: '" + generatedLine + "'";
    return msg;
  }

  /// Name of file generated by application being tested.
  const char* m_GeneratedFile;
  /// Name of file assumed to be correct.
  const char* m_GoldFile;
  /// Maximum accepted absolute difference in numeric values.
  const double m_Eps;
  /// Number of lines to skip.
  const unsigned int m_SkipLines;
  /// Maximum number of non-matching numeric values accepted.
  const unsigned int m_AllowedMismatch;
};

#endif /* MIXEDFILECHECK_H */
