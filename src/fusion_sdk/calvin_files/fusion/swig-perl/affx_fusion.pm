# This file was automatically generated by SWIG
package affx_fusion;
require Exporter;
require DynaLoader;
@ISA = qw(Exporter DynaLoader);
package affx_fusionc;
bootstrap affx_fusion;
package affx_fusion;
@EXPORT = qw( );

# ---------- BASE METHODS -------------

package affx_fusion;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package affx_fusion;

*ReadUInt32_I = *affx_fusionc::ReadUInt32_I;
*ReadInt32_I = *affx_fusionc::ReadInt32_I;
*ReadFloat_I = *affx_fusionc::ReadFloat_I;
*ReadUInt16_I = *affx_fusionc::ReadUInt16_I;
*ReadInt16_I = *affx_fusionc::ReadInt16_I;
*ReadCString_I = *affx_fusionc::ReadCString_I;
*ReadString_I = *affx_fusionc::ReadString_I;
*ReadUIntLenString_I = *affx_fusionc::ReadUIntLenString_I;
*ReadUInt8 = *affx_fusionc::ReadUInt8;
*ReadInt8 = *affx_fusionc::ReadInt8;
*ReadUInt32_N = *affx_fusionc::ReadUInt32_N;
*ReadInt32_N = *affx_fusionc::ReadInt32_N;
*ReadFloat_N = *affx_fusionc::ReadFloat_N;
*ReadUInt16_N = *affx_fusionc::ReadUInt16_N;
*ReadInt16_N = *affx_fusionc::ReadInt16_N;
*ReadCString_N = *affx_fusionc::ReadCString_N;
*ReadString_N = *affx_fusionc::ReadString_N;
*ReadUIntLenString_N = *affx_fusionc::ReadUIntLenString_N;
*ReadFixedString = *affx_fusionc::ReadFixedString;
*ReadFixedCString = *affx_fusionc::ReadFixedCString;
*ReadFixedUCString = *affx_fusionc::ReadFixedUCString;
*ReadCharacterArray = *affx_fusionc::ReadCharacterArray;
*ReadNextLine = *affx_fusionc::ReadNextLine;
*ReadFloatFromOldBPMAP_N = *affx_fusionc::ReadFloatFromOldBPMAP_N;
*MmGetUInt32_I = *affx_fusionc::MmGetUInt32_I;
*MmGetInt32_I = *affx_fusionc::MmGetInt32_I;
*MmGetUInt16_I = *affx_fusionc::MmGetUInt16_I;
*MmGetInt16_I = *affx_fusionc::MmGetInt16_I;
*MmGetUInt8 = *affx_fusionc::MmGetUInt8;
*MmGetInt8 = *affx_fusionc::MmGetInt8;
*MmGetUInt32_N = *affx_fusionc::MmGetUInt32_N;
*MmGetUInt16_N = *affx_fusionc::MmGetUInt16_N;
*MmGetFloat_N = *affx_fusionc::MmGetFloat_N;
*MmGetInt32_N = *affx_fusionc::MmGetInt32_N;
*MmGetInt16_N = *affx_fusionc::MmGetInt16_N;
*MmGetFloat_I = *affx_fusionc::MmGetFloat_I;
*MmGetFloatFromOldBPMAP_N = *affx_fusionc::MmGetFloatFromOldBPMAP_N;
*MmSetUInt32_I = *affx_fusionc::MmSetUInt32_I;
*MmSetUInt16_I = *affx_fusionc::MmSetUInt16_I;
*MmSetUInt8 = *affx_fusionc::MmSetUInt8;
*MmSetFloat_I = *affx_fusionc::MmSetFloat_I;
*MmSetUInt32_N = *affx_fusionc::MmSetUInt32_N;
*MmSetUInt16_N = *affx_fusionc::MmSetUInt16_N;
*MmSetFloat_N = *affx_fusionc::MmSetFloat_N;
*ConvertFusion = *affx_fusionc::ConvertFusion;
*ConvertGCOS = *affx_fusionc::ConvertGCOS;

############# Class : affx_fusion::AffymetrixGuid ##############

package affx_fusion::AffymetrixGuid;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_AffymetrixGuid(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_AffymetrixGuid($self);
        delete $OWNER{$self};
    }
}

*GenerateNewGuid = *affx_fusionc::AffymetrixGuid_GenerateNewGuid;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::CheckSum ##############

package affx_fusion::CheckSum;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
*OnesComplementCheckSum = *affx_fusionc::CheckSum_OnesComplementCheckSum;
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_CheckSum(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_CheckSum($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::FPoint ##############

package affx_fusion::FPoint;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
*swig_x_get = *affx_fusionc::FPoint_x_get;
*swig_x_set = *affx_fusionc::FPoint_x_set;
*swig_y_get = *affx_fusionc::FPoint_y_get;
*swig_y_set = *affx_fusionc::FPoint_y_set;
*FPoint_equals = *affx_fusionc::FPoint_FPoint_equals;
*FPoint_not_equals = *affx_fusionc::FPoint_FPoint_not_equals;
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_FPoint(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_FPoint($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::FRegion ##############

package affx_fusion::FRegion;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
*Clear = *affx_fusionc::FRegion_Clear;
*swig_pts_get = *affx_fusionc::FRegion_pts_get;
*swig_pts_set = *affx_fusionc::FRegion_pts_set;
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_FRegion(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_FRegion($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::FRect ##############

package affx_fusion::FRect;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_FRect(@_);
    bless $self, $pkg if defined($self);
}

*op_FRegion = *affx_fusionc::FRect_op_FRegion;
*IsEmpty = *affx_fusionc::FRect_IsEmpty;
*swig_upperleft_get = *affx_fusionc::FRect_upperleft_get;
*swig_upperleft_set = *affx_fusionc::FRect_upperleft_set;
*swig_upperright_get = *affx_fusionc::FRect_upperright_get;
*swig_upperright_set = *affx_fusionc::FRect_upperright_set;
*swig_lowerright_get = *affx_fusionc::FRect_lowerright_get;
*swig_lowerright_set = *affx_fusionc::FRect_lowerright_set;
*swig_lowerleft_get = *affx_fusionc::FRect_lowerleft_get;
*swig_lowerleft_set = *affx_fusionc::FRect_lowerleft_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_FRect($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::Point ##############

package affx_fusion::Point;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
*swig_x_get = *affx_fusionc::Point_x_get;
*swig_x_set = *affx_fusionc::Point_x_set;
*swig_y_get = *affx_fusionc::Point_y_get;
*swig_y_set = *affx_fusionc::Point_y_set;
*Point_equals = *affx_fusionc::Point_Point_equals;
*Point_not_equals = *affx_fusionc::Point_Point_not_equals;
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_Point(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_Point($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::PointU16_t ##############

package affx_fusion::PointU16_t;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
*swig_x_get = *affx_fusionc::PointU16_t_x_get;
*swig_x_set = *affx_fusionc::PointU16_t_x_set;
*swig_y_get = *affx_fusionc::PointU16_t_y_get;
*swig_y_set = *affx_fusionc::PointU16_t_y_set;
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_PointU16_t(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_PointU16_t($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::Region ##############

package affx_fusion::Region;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
*Clear = *affx_fusionc::Region_Clear;
*swig_pts_get = *affx_fusionc::Region_pts_get;
*swig_pts_set = *affx_fusionc::Region_pts_set;
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_Region(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_Region($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::Rect ##############

package affx_fusion::Rect;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_Rect(@_);
    bless $self, $pkg if defined($self);
}

*op_Region = *affx_fusionc::Rect_op_Region;
*IsEmpty = *affx_fusionc::Rect_IsEmpty;
*swig_upperleft_get = *affx_fusionc::Rect_upperleft_get;
*swig_upperleft_set = *affx_fusionc::Rect_upperleft_set;
*swig_upperright_get = *affx_fusionc::Rect_upperright_get;
*swig_upperright_set = *affx_fusionc::Rect_upperright_set;
*swig_lowerright_get = *affx_fusionc::Rect_lowerright_get;
*swig_lowerright_set = *affx_fusionc::Rect_lowerright_set;
*swig_lowerleft_get = *affx_fusionc::Rect_lowerleft_get;
*swig_lowerleft_set = *affx_fusionc::Rect_lowerleft_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_Rect($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::DateTime ##############

package affx_fusion::DateTime;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_DateTime(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_DateTime($self);
        delete $OWNER{$self};
    }
}

*Date = *affx_fusionc::DateTime_Date;
*Time = *affx_fusionc::DateTime_Time;
*Clear = *affx_fusionc::DateTime_Clear;
*GetCurrentDateTime = *affx_fusionc::DateTime_GetCurrentDateTime;
*IsUTC = *affx_fusionc::DateTime_IsUTC;
*ToString = *affx_fusionc::DateTime_ToString;
*Parse = *affx_fusionc::DateTime_Parse;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::FileUtils ##############

package affx_fusion::FileUtils;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
*Exists = *affx_fusionc::FileUtils_Exists;
*LockFile = *affx_fusionc::FileUtils_LockFile;
*UnlockFile = *affx_fusionc::FileUtils_UnlockFile;
*ListFiles = *affx_fusionc::FileUtils_ListFiles;
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_FileUtils(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_FileUtils($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::StringUtils ##############

package affx_fusion::StringUtils;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
*STLTrimLeft = *affx_fusionc::StringUtils_STLTrimLeft;
*STLTrimRight = *affx_fusionc::StringUtils_STLTrimRight;
*ConvertWCSToMBS = *affx_fusionc::StringUtils_ConvertWCSToMBS;
*ConvertMBSToWCS = *affx_fusionc::StringUtils_ConvertMBSToWCS;
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_StringUtils(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_StringUtils($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::Subgrid ##############

package affx_fusion::Subgrid;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
*swig_row_get = *affx_fusionc::Subgrid_row_get;
*swig_row_set = *affx_fusionc::Subgrid_row_set;
*swig_col_get = *affx_fusionc::Subgrid_col_get;
*swig_col_set = *affx_fusionc::Subgrid_col_set;
*swig_pixelgrid_get = *affx_fusionc::Subgrid_pixelgrid_get;
*swig_pixelgrid_set = *affx_fusionc::Subgrid_pixelgrid_set;
*swig_cellgrid_get = *affx_fusionc::Subgrid_cellgrid_get;
*swig_cellgrid_set = *affx_fusionc::Subgrid_cellgrid_set;
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_Subgrid(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_Subgrid($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::CalvinException ##############

package affx_fusion::CalvinException;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_CalvinException(@_);
    bless $self, $pkg if defined($self);
}

*Source = *affx_fusionc::CalvinException_Source;
*Description = *affx_fusionc::CalvinException_Description;
*TimeStamp = *affx_fusionc::CalvinException_TimeStamp;
*SourceFile = *affx_fusionc::CalvinException_SourceFile;
*LineNumber = *affx_fusionc::CalvinException_LineNumber;
*ErrorCode = *affx_fusionc::CalvinException_ErrorCode;
*ToString = *affx_fusionc::CalvinException_ToString;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_CalvinException($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::NotImplementedException ##############

package affx_fusion::NotImplementedException;
@ISA = qw( affx_fusion affx_fusion::CalvinException );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_NotImplementedException(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_NotImplementedException($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::FormatException ##############

package affx_fusion::FormatException;
@ISA = qw( affx_fusion affx_fusion::CalvinException );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_FormatException(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_FormatException($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::ParameterMismatchException ##############

package affx_fusion::ParameterMismatchException;
@ISA = qw( affx_fusion affx_fusion::CalvinException );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_ParameterMismatchException(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_ParameterMismatchException($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::UnexpectedParameterException ##############

package affx_fusion::UnexpectedParameterException;
@ISA = qw( affx_fusion affx_fusion::CalvinException );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_UnexpectedParameterException(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_UnexpectedParameterException($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::OutOfRangeParameterException ##############

package affx_fusion::OutOfRangeParameterException;
@ISA = qw( affx_fusion affx_fusion::CalvinException );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_OutOfRangeParameterException(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_OutOfRangeParameterException($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::ParameterNameValuePair ##############

package affx_fusion::ParameterNameValuePair;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
*swig_Name_get = *affx_fusionc::ParameterNameValuePair_Name_get;
*swig_Name_set = *affx_fusionc::ParameterNameValuePair_Name_set;
*swig_Value_get = *affx_fusionc::ParameterNameValuePair_Value_get;
*swig_Value_set = *affx_fusionc::ParameterNameValuePair_Value_set;
*ParameterNameValuePair_copy = *affx_fusionc::ParameterNameValuePair_ParameterNameValuePair_copy;
*ParameterNameValuePair_equals_obj = *affx_fusionc::ParameterNameValuePair_ParameterNameValuePair_equals_obj;
*ParameterNameValueControlVocabulary_equals_name = *affx_fusionc::ParameterNameValuePair_ParameterNameValueControlVocabulary_equals_name;
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_ParameterNameValuePair(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_ParameterNameValuePair($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::ParameterNameValueControlVocabulary ##############

package affx_fusion::ParameterNameValueControlVocabulary;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
*swig_Name_get = *affx_fusionc::ParameterNameValueControlVocabulary_Name_get;
*swig_Name_set = *affx_fusionc::ParameterNameValueControlVocabulary_Name_set;
*swig_Value_get = *affx_fusionc::ParameterNameValueControlVocabulary_Value_get;
*swig_Value_set = *affx_fusionc::ParameterNameValueControlVocabulary_Value_set;
*swig_ControlledVocabulary_get = *affx_fusionc::ParameterNameValueControlVocabulary_ControlledVocabulary_get;
*swig_ControlledVocabulary_set = *affx_fusionc::ParameterNameValueControlVocabulary_ControlledVocabulary_set;
*ParameterNameValueControlVocabulary_copy = *affx_fusionc::ParameterNameValueControlVocabulary_ParameterNameValueControlVocabulary_copy;
*ParameterNameValueControlVocabulary_equals_obj = *affx_fusionc::ParameterNameValueControlVocabulary_ParameterNameValueControlVocabulary_equals_obj;
*ParameterNameValueControlVocabulary_equals_name = *affx_fusionc::ParameterNameValueControlVocabulary_ParameterNameValueControlVocabulary_equals_name;
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_ParameterNameValueControlVocabulary(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_ParameterNameValueControlVocabulary($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::ParameterDataValue ##############

package affx_fusion::ParameterDataValue;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
*swig_i8_get = *affx_fusionc::ParameterDataValue_i8_get;
*swig_i8_set = *affx_fusionc::ParameterDataValue_i8_set;
*swig_i16_get = *affx_fusionc::ParameterDataValue_i16_get;
*swig_i16_set = *affx_fusionc::ParameterDataValue_i16_set;
*swig_i32_get = *affx_fusionc::ParameterDataValue_i32_get;
*swig_i32_set = *affx_fusionc::ParameterDataValue_i32_set;
*swig_iu8_get = *affx_fusionc::ParameterDataValue_iu8_get;
*swig_iu8_set = *affx_fusionc::ParameterDataValue_iu8_set;
*swig_iu16_get = *affx_fusionc::ParameterDataValue_iu16_get;
*swig_iu16_set = *affx_fusionc::ParameterDataValue_iu16_set;
*swig_iu32_get = *affx_fusionc::ParameterDataValue_iu32_get;
*swig_iu32_set = *affx_fusionc::ParameterDataValue_iu32_set;
*swig_f32_get = *affx_fusionc::ParameterDataValue_f32_get;
*swig_f32_set = *affx_fusionc::ParameterDataValue_f32_set;
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_ParameterDataValue(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_ParameterDataValue($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::ParameterValue ##############

package affx_fusion::ParameterValue;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
*swig_paramValueType_get = *affx_fusionc::ParameterValue_paramValueType_get;
*swig_paramValueType_set = *affx_fusionc::ParameterValue_paramValueType_set;
*swig_valueSize_get = *affx_fusionc::ParameterValue_valueSize_get;
*swig_valueSize_set = *affx_fusionc::ParameterValue_valueSize_set;
*swig_paramValue_get = *affx_fusionc::ParameterValue_paramValue_get;
*swig_paramValue_set = *affx_fusionc::ParameterValue_paramValue_set;
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_ParameterValue(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_ParameterValue($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::MIMEValue ##############

package affx_fusion::MIMEValue;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_MIMEValue(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_MIMEValue($self);
        delete $OWNER{$self};
    }
}

*MIMEValue_copy = *affx_fusionc::MIMEValue_MIMEValue_copy;
*MIMEValue_equals = *affx_fusionc::MIMEValue_MIMEValue_equals;
*MIMEValue_not_equals = *affx_fusionc::MIMEValue_MIMEValue_not_equals;
*SetValue = *affx_fusionc::MIMEValue_SetValue;
*GetValue = *affx_fusionc::MIMEValue_GetValue;
*Size = *affx_fusionc::MIMEValue_Size;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::ParameterNameValueType ##############

package affx_fusion::ParameterNameValueType;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_ParameterNameValueType(@_);
    bless $self, $pkg if defined($self);
}

*ParameterNameValueType_copy = *affx_fusionc::ParameterNameValueType_ParameterNameValueType_copy;
*ParameterNameValueType_equals_obj = *affx_fusionc::ParameterNameValueType_ParameterNameValueType_equals_obj;
*ParameterNameValueType_not_equals_obj = *affx_fusionc::ParameterNameValueType_ParameterNameValueType_not_equals_obj;
*ParameterNameValueType_equals_name = *affx_fusionc::ParameterNameValueType_ParameterNameValueType_equals_name;
*ParameterNameValueType_not_equals_name = *affx_fusionc::ParameterNameValueType_ParameterNameValueType_not_equals_name;
*ParameterNameValueType_less_than = *affx_fusionc::ParameterNameValueType_ParameterNameValueType_less_than;
*ParameterNameValueType_greater_than = *affx_fusionc::ParameterNameValueType_ParameterNameValueType_greater_than;
*GetName = *affx_fusionc::ParameterNameValueType_GetName;
*SetName = *affx_fusionc::ParameterNameValueType_SetName;
*Int8Type = *affx_fusionc::ParameterNameValueType_Int8Type;
*UInt8Type = *affx_fusionc::ParameterNameValueType_UInt8Type;
*Int16Type = *affx_fusionc::ParameterNameValueType_Int16Type;
*UInt16Type = *affx_fusionc::ParameterNameValueType_UInt16Type;
*Int32Type = *affx_fusionc::ParameterNameValueType_Int32Type;
*UInt32Type = *affx_fusionc::ParameterNameValueType_UInt32Type;
*FloatType = *affx_fusionc::ParameterNameValueType_FloatType;
*TextType = *affx_fusionc::ParameterNameValueType_TextType;
*AsciiType = *affx_fusionc::ParameterNameValueType_AsciiType;
*UnknownType = *affx_fusionc::ParameterNameValueType_UnknownType;
*GetParameterType = *affx_fusionc::ParameterNameValueType_GetParameterType;
*GetValueInt8 = *affx_fusionc::ParameterNameValueType_GetValueInt8;
*SetValueInt8 = *affx_fusionc::ParameterNameValueType_SetValueInt8;
*GetValueUInt8 = *affx_fusionc::ParameterNameValueType_GetValueUInt8;
*SetValueUInt8 = *affx_fusionc::ParameterNameValueType_SetValueUInt8;
*GetValueInt16 = *affx_fusionc::ParameterNameValueType_GetValueInt16;
*SetValueInt16 = *affx_fusionc::ParameterNameValueType_SetValueInt16;
*GetValueUInt16 = *affx_fusionc::ParameterNameValueType_GetValueUInt16;
*SetValueUInt16 = *affx_fusionc::ParameterNameValueType_SetValueUInt16;
*GetValueInt32 = *affx_fusionc::ParameterNameValueType_GetValueInt32;
*SetValueInt32 = *affx_fusionc::ParameterNameValueType_SetValueInt32;
*GetValueUInt32 = *affx_fusionc::ParameterNameValueType_GetValueUInt32;
*SetValueUInt32 = *affx_fusionc::ParameterNameValueType_SetValueUInt32;
*GetValueFloat = *affx_fusionc::ParameterNameValueType_GetValueFloat;
*SetValueFloat = *affx_fusionc::ParameterNameValueType_SetValueFloat;
*GetValueText = *affx_fusionc::ParameterNameValueType_GetValueText;
*SetValueText = *affx_fusionc::ParameterNameValueType_SetValueText;
*GetValueAscii = *affx_fusionc::ParameterNameValueType_GetValueAscii;
*SetValueAscii = *affx_fusionc::ParameterNameValueType_SetValueAscii;
*GetMIMEType = *affx_fusionc::ParameterNameValueType_GetMIMEType;
*SetMIMEType = *affx_fusionc::ParameterNameValueType_SetMIMEType;
*GetMIMEValue = *affx_fusionc::ParameterNameValueType_GetMIMEValue;
*SetMIMEValue = *affx_fusionc::ParameterNameValueType_SetMIMEValue;
*ToString = *affx_fusionc::ParameterNameValueType_ToString;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_ParameterNameValueType($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::ArrayAttributes ##############

package affx_fusion::ArrayAttributes;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_ArrayAttributes(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_ArrayAttributes($self);
        delete $OWNER{$self};
    }
}

*Identifier = *affx_fusionc::ArrayAttributes_Identifier;
*Attributes = *affx_fusionc::ArrayAttributes_Attributes;
*Clear = *affx_fusionc::ArrayAttributes_Clear;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::ArrayAuditEntry ##############

package affx_fusion::ArrayAuditEntry;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_ArrayAuditEntry(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_ArrayAuditEntry($self);
        delete $OWNER{$self};
    }
}

*UserName = *affx_fusionc::ArrayAuditEntry_UserName;
*DateTime = *affx_fusionc::ArrayAuditEntry_DateTime;
*ActionType = *affx_fusionc::ArrayAuditEntry_ActionType;
*ArrayGuid = *affx_fusionc::ArrayAuditEntry_ArrayGuid;
*InputFileGuids = *affx_fusionc::ArrayAuditEntry_InputFileGuids;
*OutputFileGuids = *affx_fusionc::ArrayAuditEntry_OutputFileGuids;
*ActionParameters = *affx_fusionc::ArrayAuditEntry_ActionParameters;
*Clear = *affx_fusionc::ArrayAuditEntry_Clear;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::ArrayData ##############

package affx_fusion::ArrayData;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_ArrayData(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_ArrayData($self);
        delete $OWNER{$self};
    }
}

*ArraySetIdentifier = *affx_fusionc::ArrayData_ArraySetIdentifier;
*PhysicalArraysAttributes = *affx_fusionc::ArrayData_PhysicalArraysAttributes;
*UserAttributes = *affx_fusionc::ArrayData_UserAttributes;
*Clear = *affx_fusionc::ArrayData_Clear;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::CDFData ##############

package affx_fusion::CDFData;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_CDFData(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_CDFData($self);
        delete $OWNER{$self};
    }
}

*Clear = *affx_fusionc::CDFData_Clear;
*SetFilename = *affx_fusionc::CDFData_SetFilename;
*GetFilename = *affx_fusionc::CDFData_GetFilename;
*GetProbeSetCnt = *affx_fusionc::CDFData_GetProbeSetCnt;
*SetProbeSetCnt = *affx_fusionc::CDFData_SetProbeSetCnt;
*SetArrayRows = *affx_fusionc::CDFData_SetArrayRows;
*GetArrayRows = *affx_fusionc::CDFData_GetArrayRows;
*SetArrayCols = *affx_fusionc::CDFData_SetArrayCols;
*GetArrayCols = *affx_fusionc::CDFData_GetArrayCols;
*SetRefSequence = *affx_fusionc::CDFData_SetRefSequence;
*GetRefSequence = *affx_fusionc::CDFData_GetRefSequence;
*GetDataTypeId = *affx_fusionc::CDFData_GetDataTypeId;
*GetFileHeader = *affx_fusionc::CDFData_GetFileHeader;
*GetGenericData = *affx_fusionc::CDFData_GetGenericData;
*GetProbeSetInformation = *affx_fusionc::CDFData_GetProbeSetInformation;
*GetQCProbeSetInformation = *affx_fusionc::CDFData_GetQCProbeSetInformation;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::CDFProbeGroupInformation ##############

package affx_fusion::CDFProbeGroupInformation;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_CDFProbeGroupInformation(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_CDFProbeGroupInformation($self);
        delete $OWNER{$self};
    }
}

*GetDirection = *affx_fusionc::CDFProbeGroupInformation_GetDirection;
*GetNumLists = *affx_fusionc::CDFProbeGroupInformation_GetNumLists;
*GetNumCells = *affx_fusionc::CDFProbeGroupInformation_GetNumCells;
*GetNumCellsPerList = *affx_fusionc::CDFProbeGroupInformation_GetNumCellsPerList;
*GetName = *affx_fusionc::CDFProbeGroupInformation_GetName;
*GetCell = *affx_fusionc::CDFProbeGroupInformation_GetCell;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::CDFProbeInformation ##############

package affx_fusion::CDFProbeInformation;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_CDFProbeInformation(@_);
    bless $self, $pkg if defined($self);
}

*GetListIndex = *affx_fusionc::CDFProbeInformation_GetListIndex;
*GetExpos = *affx_fusionc::CDFProbeInformation_GetExpos;
*GetX = *affx_fusionc::CDFProbeInformation_GetX;
*GetY = *affx_fusionc::CDFProbeInformation_GetY;
*GetPBase = *affx_fusionc::CDFProbeInformation_GetPBase;
*GetTBase = *affx_fusionc::CDFProbeInformation_GetTBase;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_CDFProbeInformation($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::CDFProbeSetInformation ##############

package affx_fusion::CDFProbeSetInformation;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_CDFProbeSetInformation(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_CDFProbeSetInformation($self);
        delete $OWNER{$self};
    }
}

*GetName = *affx_fusionc::CDFProbeSetInformation_GetName;
*GetDirection = *affx_fusionc::CDFProbeSetInformation_GetDirection;
*GetNumLists = *affx_fusionc::CDFProbeSetInformation_GetNumLists;
*GetNumGroups = *affx_fusionc::CDFProbeSetInformation_GetNumGroups;
*GetNumCells = *affx_fusionc::CDFProbeSetInformation_GetNumCells;
*GetNumCellsPerList = *affx_fusionc::CDFProbeSetInformation_GetNumCellsPerList;
*GetProbeSetNumber = *affx_fusionc::CDFProbeSetInformation_GetProbeSetNumber;
*GetGroupInformation = *affx_fusionc::CDFProbeSetInformation_GetGroupInformation;
*GetProbeSetType = *affx_fusionc::CDFProbeSetInformation_GetProbeSetType;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::CDFQCProbeInformation ##############

package affx_fusion::CDFQCProbeInformation;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_CDFQCProbeInformation(@_);
    bless $self, $pkg if defined($self);
}

*GetX = *affx_fusionc::CDFQCProbeInformation_GetX;
*GetY = *affx_fusionc::CDFQCProbeInformation_GetY;
*GetPLen = *affx_fusionc::CDFQCProbeInformation_GetPLen;
*IsPerfectMatchProbe = *affx_fusionc::CDFQCProbeInformation_IsPerfectMatchProbe;
*IsBackgroundProbe = *affx_fusionc::CDFQCProbeInformation_IsBackgroundProbe;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_CDFQCProbeInformation($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::CDFQCProbeSetInformation ##############

package affx_fusion::CDFQCProbeSetInformation;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_CDFQCProbeSetInformation(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_CDFQCProbeSetInformation($self);
        delete $OWNER{$self};
    }
}

*GetQCProbeSetType = *affx_fusionc::CDFQCProbeSetInformation_GetQCProbeSetType;
*GetNumCells = *affx_fusionc::CDFQCProbeSetInformation_GetNumCells;
*GetProbeInformation = *affx_fusionc::CDFQCProbeSetInformation_GetProbeInformation;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::CHPBackgroundZone ##############

package affx_fusion::CHPBackgroundZone;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_CHPBackgroundZone(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_CHPBackgroundZone($self);
        delete $OWNER{$self};
    }
}

*Clear = *affx_fusionc::CHPBackgroundZone_Clear;
*CHPBackgroundZone_assign = *affx_fusionc::CHPBackgroundZone_CHPBackgroundZone_assign;
*GetCenterX = *affx_fusionc::CHPBackgroundZone_GetCenterX;
*GetCenterY = *affx_fusionc::CHPBackgroundZone_GetCenterY;
*GetBackground = *affx_fusionc::CHPBackgroundZone_GetBackground;
*GetSmoothFactor = *affx_fusionc::CHPBackgroundZone_GetSmoothFactor;
*SetCenterX = *affx_fusionc::CHPBackgroundZone_SetCenterX;
*SetCenterY = *affx_fusionc::CHPBackgroundZone_SetCenterY;
*SetBackground = *affx_fusionc::CHPBackgroundZone_SetBackground;
*SetSmoothFactor = *affx_fusionc::CHPBackgroundZone_SetSmoothFactor;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::CHPData ##############

package affx_fusion::CHPData;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_CHPData(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_CHPData($self);
        delete $OWNER{$self};
    }
}

*Clear = *affx_fusionc::CHPData_Clear;
*SetFilename = *affx_fusionc::CHPData_SetFilename;
*GetFilename = *affx_fusionc::CHPData_GetFilename;
*GetVersion = *affx_fusionc::CHPData_GetVersion;
*GetMagic = *affx_fusionc::CHPData_GetMagic;
*GetRows = *affx_fusionc::CHPData_GetRows;
*SetRows = *affx_fusionc::CHPData_SetRows;
*GetCols = *affx_fusionc::CHPData_GetCols;
*SetCols = *affx_fusionc::CHPData_SetCols;
*GetProgId = *affx_fusionc::CHPData_GetProgId;
*SetProgId = *affx_fusionc::CHPData_SetProgId;
*GetArrayType = *affx_fusionc::CHPData_GetArrayType;
*GetAssayType = *affx_fusionc::CHPData_GetAssayType;
*SetArrayType = *affx_fusionc::CHPData_SetArrayType;
*GetAlgName = *affx_fusionc::CHPData_GetAlgName;
*SetAlgName = *affx_fusionc::CHPData_SetAlgName;
*GetParentCell = *affx_fusionc::CHPData_GetParentCell;
*SetParentCell = *affx_fusionc::CHPData_SetParentCell;
*GetAlgVersion = *affx_fusionc::CHPData_GetAlgVersion;
*SetAlgVersion = *affx_fusionc::CHPData_SetAlgVersion;
*AddAlgParam = *affx_fusionc::CHPData_AddAlgParam;
*GetAlgParam = *affx_fusionc::CHPData_GetAlgParam;
*AddChipSum = *affx_fusionc::CHPData_AddChipSum;
*GetChipSums = *affx_fusionc::CHPData_GetChipSums;
*GetChipSum = *affx_fusionc::CHPData_GetChipSum;
*GetFileHeader = *affx_fusionc::CHPData_GetFileHeader;
*GetGenericData = *affx_fusionc::CHPData_GetGenericData;
*SetEntryCount = *affx_fusionc::CHPData_SetEntryCount;
*GetEntryCount = *affx_fusionc::CHPData_GetEntryCount;
*GetExpressionEntry = *affx_fusionc::CHPData_GetExpressionEntry;
*GetGenotypeEntry = *affx_fusionc::CHPData_GetGenotypeEntry;
*GetUniversalEntry = *affx_fusionc::CHPData_GetUniversalEntry;
*GetBackgroundZoneCnt = *affx_fusionc::CHPData_GetBackgroundZoneCnt;
*SetBackgroundZoneCnt = *affx_fusionc::CHPData_SetBackgroundZoneCnt;
*GetBackgroundZone = *affx_fusionc::CHPData_GetBackgroundZone;
*GetBackgroundZones = *affx_fusionc::CHPData_GetBackgroundZones;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::CHPExpressionEntry ##############

package affx_fusion::CHPExpressionEntry;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_CHPExpressionEntry(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_CHPExpressionEntry($self);
        delete $OWNER{$self};
    }
}

*Clear = *affx_fusionc::CHPExpressionEntry_Clear;
*CHPExpressionEntry_assign = *affx_fusionc::CHPExpressionEntry_CHPExpressionEntry_assign;
*GetProbeSetName = *affx_fusionc::CHPExpressionEntry_GetProbeSetName;
*GetDetection = *affx_fusionc::CHPExpressionEntry_GetDetection;
*GetDetectionPValue = *affx_fusionc::CHPExpressionEntry_GetDetectionPValue;
*GetSignal = *affx_fusionc::CHPExpressionEntry_GetSignal;
*GetNumPairs = *affx_fusionc::CHPExpressionEntry_GetNumPairs;
*GetNumPairsUsed = *affx_fusionc::CHPExpressionEntry_GetNumPairsUsed;
*GetChange = *affx_fusionc::CHPExpressionEntry_GetChange;
*GetChangePValue = *affx_fusionc::CHPExpressionEntry_GetChangePValue;
*GetSigLogRatio = *affx_fusionc::CHPExpressionEntry_GetSigLogRatio;
*GetSigLogRatioLo = *affx_fusionc::CHPExpressionEntry_GetSigLogRatioLo;
*GetSigLogRatioHi = *affx_fusionc::CHPExpressionEntry_GetSigLogRatioHi;
*GetCommonPairs = *affx_fusionc::CHPExpressionEntry_GetCommonPairs;
*SetProbeSetName = *affx_fusionc::CHPExpressionEntry_SetProbeSetName;
*SetDetection = *affx_fusionc::CHPExpressionEntry_SetDetection;
*SetDetectionPValue = *affx_fusionc::CHPExpressionEntry_SetDetectionPValue;
*SetSignal = *affx_fusionc::CHPExpressionEntry_SetSignal;
*SetNumPairs = *affx_fusionc::CHPExpressionEntry_SetNumPairs;
*SetNumPairsUsed = *affx_fusionc::CHPExpressionEntry_SetNumPairsUsed;
*SetChange = *affx_fusionc::CHPExpressionEntry_SetChange;
*SetChangePValue = *affx_fusionc::CHPExpressionEntry_SetChangePValue;
*SetSigLogRatio = *affx_fusionc::CHPExpressionEntry_SetSigLogRatio;
*SetSigLogRatioLo = *affx_fusionc::CHPExpressionEntry_SetSigLogRatioLo;
*SetSigLogRatioHi = *affx_fusionc::CHPExpressionEntry_SetSigLogRatioHi;
*SetCommonPairs = *affx_fusionc::CHPExpressionEntry_SetCommonPairs;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::CHPGenotypeEntry ##############

package affx_fusion::CHPGenotypeEntry;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_CHPGenotypeEntry(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_CHPGenotypeEntry($self);
        delete $OWNER{$self};
    }
}

*Clear = *affx_fusionc::CHPGenotypeEntry_Clear;
*CHPGenotypeEntry_assign = *affx_fusionc::CHPGenotypeEntry_CHPGenotypeEntry_assign;
*GetProbeSetName = *affx_fusionc::CHPGenotypeEntry_GetProbeSetName;
*GetCall = *affx_fusionc::CHPGenotypeEntry_GetCall;
*GetConfidence = *affx_fusionc::CHPGenotypeEntry_GetConfidence;
*GetRAS1 = *affx_fusionc::CHPGenotypeEntry_GetRAS1;
*GetRAS2 = *affx_fusionc::CHPGenotypeEntry_GetRAS2;
*GetAACall = *affx_fusionc::CHPGenotypeEntry_GetAACall;
*GetABCall = *affx_fusionc::CHPGenotypeEntry_GetABCall;
*GetBBCall = *affx_fusionc::CHPGenotypeEntry_GetBBCall;
*GetNoCall = *affx_fusionc::CHPGenotypeEntry_GetNoCall;
*SetProbeSetName = *affx_fusionc::CHPGenotypeEntry_SetProbeSetName;
*SetCall = *affx_fusionc::CHPGenotypeEntry_SetCall;
*SetConfidence = *affx_fusionc::CHPGenotypeEntry_SetConfidence;
*SetRAS1 = *affx_fusionc::CHPGenotypeEntry_SetRAS1;
*SetRAS2 = *affx_fusionc::CHPGenotypeEntry_SetRAS2;
*SetAACall = *affx_fusionc::CHPGenotypeEntry_SetAACall;
*SetABCall = *affx_fusionc::CHPGenotypeEntry_SetABCall;
*SetBBCall = *affx_fusionc::CHPGenotypeEntry_SetBBCall;
*SetNoCall = *affx_fusionc::CHPGenotypeEntry_SetNoCall;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::CHPUniversalEntry ##############

package affx_fusion::CHPUniversalEntry;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_CHPUniversalEntry(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_CHPUniversalEntry($self);
        delete $OWNER{$self};
    }
}

*Clear = *affx_fusionc::CHPUniversalEntry_Clear;
*CHPUniversalEntry_assign = *affx_fusionc::CHPUniversalEntry_CHPUniversalEntry_assign;
*GetBackground = *affx_fusionc::CHPUniversalEntry_GetBackground;
*SetBackground = *affx_fusionc::CHPUniversalEntry_SetBackground;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::XYCoord ##############

package affx_fusion::XYCoord;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_XYCoord(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_XYCoord($self);
        delete $OWNER{$self};
    }
}

*swig_xCoord_get = *affx_fusionc::XYCoord_xCoord_get;
*swig_xCoord_set = *affx_fusionc::XYCoord_xCoord_set;
*swig_yCoord_get = *affx_fusionc::XYCoord_yCoord_get;
*swig_yCoord_set = *affx_fusionc::XYCoord_yCoord_set;
*XYCoord_assign = *affx_fusionc::XYCoord_XYCoord_assign;
*XYCoord_equals = *affx_fusionc::XYCoord_XYCoord_equals;
*XYCoord_not_equals = *affx_fusionc::XYCoord_XYCoord_not_equals;
*XYCoord_less_than = *affx_fusionc::XYCoord_XYCoord_less_than;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::CelFileData ##############

package affx_fusion::CelFileData;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_CelFileData(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_CelFileData($self);
        delete $OWNER{$self};
    }
}

*Clear = *affx_fusionc::CelFileData_Clear;
*SetFilename = *affx_fusionc::CelFileData_SetFilename;
*GetFilename = *affx_fusionc::CelFileData_GetFilename;
*SetIntensityCount = *affx_fusionc::CelFileData_SetIntensityCount;
*SetStdDevCount = *affx_fusionc::CelFileData_SetStdDevCount;
*SetPixelCount = *affx_fusionc::CelFileData_SetPixelCount;
*SetOutlierCount = *affx_fusionc::CelFileData_SetOutlierCount;
*SetMaskCount = *affx_fusionc::CelFileData_SetMaskCount;
*GetFileHeader = *affx_fusionc::CelFileData_GetFileHeader;
*GetVersion = *affx_fusionc::CelFileData_GetVersion;
*SetArrayType = *affx_fusionc::CelFileData_SetArrayType;
*GetArrayType = *affx_fusionc::CelFileData_GetArrayType;
*SetAlgorithmName = *affx_fusionc::CelFileData_SetAlgorithmName;
*GetAlgorithmName = *affx_fusionc::CelFileData_GetAlgorithmName;
*SetRows = *affx_fusionc::CelFileData_SetRows;
*GetRows = *affx_fusionc::CelFileData_GetRows;
*SetCols = *affx_fusionc::CelFileData_SetCols;
*GetCols = *affx_fusionc::CelFileData_GetCols;
*GetNumCells = *affx_fusionc::CelFileData_GetNumCells;
*GetAlgorithmParameters = *affx_fusionc::CelFileData_GetAlgorithmParameters;
*FindAlgorithmParameter = *affx_fusionc::CelFileData_FindAlgorithmParameter;
*AddAlgorithmParameter = *affx_fusionc::CelFileData_AddAlgorithmParameter;
*GetData = *affx_fusionc::CelFileData_GetData;
*HasStdev = *affx_fusionc::CelFileData_HasStdev;
*HasNumPixels = *affx_fusionc::CelFileData_HasNumPixels;
*GetIntensities = *affx_fusionc::CelFileData_GetIntensities;
*GetStdev = *affx_fusionc::CelFileData_GetStdev;
*GetNumPixels = *affx_fusionc::CelFileData_GetNumPixels;
*GetOutliers = *affx_fusionc::CelFileData_GetOutliers;
*GetMasked = *affx_fusionc::CelFileData_GetMasked;
*GetOutlierCoords = *affx_fusionc::CelFileData_GetOutlierCoords;
*GetMaskedCoords = *affx_fusionc::CelFileData_GetMaskedCoords;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::ColumnType ##############

package affx_fusion::ColumnType;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_ColumnType(@_);
    bless $self, $pkg if defined($self);
}

*ColumnType_equals = *affx_fusionc::ColumnType_ColumnType_equals;
*ColumnType_not_equals = *affx_fusionc::ColumnType_ColumnType_not_equals;
*GetColumnType = *affx_fusionc::ColumnType_GetColumnType;
*GetSize = *affx_fusionc::ColumnType_GetSize;
*GetLength = *affx_fusionc::ColumnType_GetLength;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_ColumnType($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::ByteColumnType ##############

package affx_fusion::ByteColumnType;
@ISA = qw( affx_fusion affx_fusion::ColumnType );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_ByteColumnType(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_ByteColumnType($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::UByteColumnType ##############

package affx_fusion::UByteColumnType;
@ISA = qw( affx_fusion affx_fusion::ColumnType );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_UByteColumnType(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_UByteColumnType($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::ShortColumnType ##############

package affx_fusion::ShortColumnType;
@ISA = qw( affx_fusion affx_fusion::ColumnType );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_ShortColumnType(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_ShortColumnType($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::UShortColumnType ##############

package affx_fusion::UShortColumnType;
@ISA = qw( affx_fusion affx_fusion::ColumnType );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_UShortColumnType(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_UShortColumnType($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::IntColumnType ##############

package affx_fusion::IntColumnType;
@ISA = qw( affx_fusion affx_fusion::ColumnType );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_IntColumnType(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_IntColumnType($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::UIntColumnType ##############

package affx_fusion::UIntColumnType;
@ISA = qw( affx_fusion affx_fusion::ColumnType );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_UIntColumnType(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_UIntColumnType($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::FloatColumnType ##############

package affx_fusion::FloatColumnType;
@ISA = qw( affx_fusion affx_fusion::ColumnType );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_FloatColumnType(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_FloatColumnType($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::ASCIIColumnType ##############

package affx_fusion::ASCIIColumnType;
@ISA = qw( affx_fusion affx_fusion::ColumnType );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_ASCIIColumnType(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_ASCIIColumnType($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::UnicodeColumnType ##############

package affx_fusion::UnicodeColumnType;
@ISA = qw( affx_fusion affx_fusion::ColumnType );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_UnicodeColumnType(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_UnicodeColumnType($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::DataSetNotOpenException ##############

package affx_fusion::DataSetNotOpenException;
@ISA = qw( affx_fusion affx_fusion::CalvinException );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_DataSetNotOpenException(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_DataSetNotOpenException($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::ColumnIndexOutOfBoundsException ##############

package affx_fusion::ColumnIndexOutOfBoundsException;
@ISA = qw( affx_fusion affx_fusion::CalvinException );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_ColumnIndexOutOfBoundsException(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_ColumnIndexOutOfBoundsException($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::RowIndexOutOfBoundsException ##############

package affx_fusion::RowIndexOutOfBoundsException;
@ISA = qw( affx_fusion affx_fusion::CalvinException );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_RowIndexOutOfBoundsException(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_RowIndexOutOfBoundsException($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::UnexpectedColumnTypeException ##############

package affx_fusion::UnexpectedColumnTypeException;
@ISA = qw( affx_fusion affx_fusion::CalvinException );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_UnexpectedColumnTypeException(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_UnexpectedColumnTypeException($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::DataGroupNotFoundException ##############

package affx_fusion::DataGroupNotFoundException;
@ISA = qw( affx_fusion affx_fusion::CalvinException );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_DataGroupNotFoundException(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_DataGroupNotFoundException($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::DataSetNotFoundException ##############

package affx_fusion::DataSetNotFoundException;
@ISA = qw( affx_fusion affx_fusion::CalvinException );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_DataSetNotFoundException(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_DataSetNotFoundException($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::ProbeSetNotFoundException ##############

package affx_fusion::ProbeSetNotFoundException;
@ISA = qw( affx_fusion affx_fusion::CalvinException );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_ProbeSetNotFoundException(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_ProbeSetNotFoundException($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::CDFAccessNotSupportedByModeException ##############

package affx_fusion::CDFAccessNotSupportedByModeException;
@ISA = qw( affx_fusion affx_fusion::CalvinException );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_CDFAccessNotSupportedByModeException(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_CDFAccessNotSupportedByModeException($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::DataGroup ##############

package affx_fusion::DataGroup;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_DataGroup(@_);
    bless $self, $pkg if defined($self);
}

*Header = *affx_fusionc::DataGroup_Header;
*DataSet = *affx_fusionc::DataGroup_DataSet;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_DataGroup($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::DataGroupHeader ##############

package affx_fusion::DataGroupHeader;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_DataGroupHeader(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_DataGroupHeader($self);
        delete $OWNER{$self};
    }
}

*Clear = *affx_fusionc::DataGroupHeader_Clear;
*SetName = *affx_fusionc::DataGroupHeader_SetName;
*GetName = *affx_fusionc::DataGroupHeader_GetName;
*GetDataSetCnt = *affx_fusionc::DataGroupHeader_GetDataSetCnt;
*AddDataSetHdr = *affx_fusionc::DataGroupHeader_AddDataSetHdr;
*GetDataSet = *affx_fusionc::DataGroupHeader_GetDataSet;
*GetDataSetConst = *affx_fusionc::DataGroupHeader_GetDataSetConst;
*GetDataSetIterators = *affx_fusionc::DataGroupHeader_GetDataSetIterators;
*SetDataSetPos = *affx_fusionc::DataGroupHeader_SetDataSetPos;
*GetDataSetPos = *affx_fusionc::DataGroupHeader_GetDataSetPos;
*SetNextCubePos = *affx_fusionc::DataGroupHeader_SetNextCubePos;
*GetNextCubePos = *affx_fusionc::DataGroupHeader_GetNextCubePos;
*FindDataSetHeader = *affx_fusionc::DataGroupHeader_FindDataSetHeader;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::DataSet ##############

package affx_fusion::DataSet;
@ISA = qw( affx_fusion );
%OWNER = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_DataSet(@_);
    bless $self, $pkg if defined($self);
}

*Delete = *affx_fusionc::DataSet_Delete;
*Open = *affx_fusionc::DataSet_Open;
*Close = *affx_fusionc::DataSet_Close;
*Header = *affx_fusionc::DataSet_Header;
*Rows = *affx_fusionc::DataSet_Rows;
*Cols = *affx_fusionc::DataSet_Cols;
*IsOpen = *affx_fusionc::DataSet_IsOpen;
*GetData = *affx_fusionc::DataSet_GetData;
*GetDataRaw = *affx_fusionc::DataSet_GetDataRaw;
*CheckRowColumnAndType = *affx_fusionc::DataSet_CheckRowColumnAndType;
*BytesPerRow = *affx_fusionc::DataSet_BytesPerRow;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::DataSetHeader ##############

package affx_fusion::DataSetHeader;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_DataSetHeader(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_DataSetHeader($self);
        delete $OWNER{$self};
    }
}

*Clear = *affx_fusionc::DataSetHeader_Clear;
*GetDataSize = *affx_fusionc::DataSetHeader_GetDataSize;
*GetRowSize = *affx_fusionc::DataSetHeader_GetRowSize;
*SetName = *affx_fusionc::DataSetHeader_SetName;
*GetName = *affx_fusionc::DataSetHeader_GetName;
*GetNameValParamCnt = *affx_fusionc::DataSetHeader_GetNameValParamCnt;
*AddNameValParam = *affx_fusionc::DataSetHeader_AddNameValParam;
*GetNameValIterators = *affx_fusionc::DataSetHeader_GetNameValIterators;
*FindNameValParam = *affx_fusionc::DataSetHeader_FindNameValParam;
*AddColumnType = *affx_fusionc::DataSetHeader_AddColumnType;
*AddIntColumnType = *affx_fusionc::DataSetHeader_AddIntColumnType;
*AddUIntColumnType = *affx_fusionc::DataSetHeader_AddUIntColumnType;
*AddShortColumnType = *affx_fusionc::DataSetHeader_AddShortColumnType;
*AddUShortColumnType = *affx_fusionc::DataSetHeader_AddUShortColumnType;
*AddByteColumnType = *affx_fusionc::DataSetHeader_AddByteColumnType;
*AddUByteColumnType = *affx_fusionc::DataSetHeader_AddUByteColumnType;
*AddFloatColumnType = *affx_fusionc::DataSetHeader_AddFloatColumnType;
*AddAsciiColumnType = *affx_fusionc::DataSetHeader_AddAsciiColumnType;
*AddUnicodeColumnType = *affx_fusionc::DataSetHeader_AddUnicodeColumnType;
*GetColumnType = *affx_fusionc::DataSetHeader_GetColumnType;
*GetRowCnt = *affx_fusionc::DataSetHeader_GetRowCnt;
*SetRowCnt = *affx_fusionc::DataSetHeader_SetRowCnt;
*GetColumnCnt = *affx_fusionc::DataSetHeader_GetColumnCnt;
*SetHeaderStartFilePos = *affx_fusionc::DataSetHeader_SetHeaderStartFilePos;
*GetHeaderStartFilePos = *affx_fusionc::DataSetHeader_GetHeaderStartFilePos;
*SetDataStartFilePos = *affx_fusionc::DataSetHeader_SetDataStartFilePos;
*GetDataStartFilePos = *affx_fusionc::DataSetHeader_GetDataStartFilePos;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::FileHeader ##############

package affx_fusion::FileHeader;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_FileHeader(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_FileHeader($self);
        delete $OWNER{$self};
    }
}

*Clear = *affx_fusionc::FileHeader_Clear;
*SetFilename = *affx_fusionc::FileHeader_SetFilename;
*GetFilename = *affx_fusionc::FileHeader_GetFilename;
*GetMagicNumber = *affx_fusionc::FileHeader_GetMagicNumber;
*GetVersion = *affx_fusionc::FileHeader_GetVersion;
*GetDataGroupCnt = *affx_fusionc::FileHeader_GetDataGroupCnt;
*AddDataGroupHdr = *affx_fusionc::FileHeader_AddDataGroupHdr;
*GetDataGroup = *affx_fusionc::FileHeader_GetDataGroup;
*GetDataGroupConst = *affx_fusionc::FileHeader_GetDataGroupConst;
*GetDataGroupIts = *affx_fusionc::FileHeader_GetDataGroupIts;
*SetGenericDataHdr = *affx_fusionc::FileHeader_SetGenericDataHdr;
*GetGenericDataHdr = *affx_fusionc::FileHeader_GetGenericDataHdr;
*FindDataGroupHeader = *affx_fusionc::FileHeader_FindDataGroupHeader;
*GetNumDataGroups = *affx_fusionc::FileHeader_GetNumDataGroups;
*SetNumDataGroups = *affx_fusionc::FileHeader_SetNumDataGroups;
*GetFirstDataGroupFilePos = *affx_fusionc::FileHeader_GetFirstDataGroupFilePos;
*SetFirstDataGroupFilePos = *affx_fusionc::FileHeader_SetFirstDataGroupFilePos;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::GenericData ##############

package affx_fusion::GenericData;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_GenericData(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_GenericData($self);
        delete $OWNER{$self};
    }
}

*FileIdentifier = *affx_fusionc::GenericData_FileIdentifier;
*ArrayFileIdentifier = *affx_fusionc::GenericData_ArrayFileIdentifier;
*Header = *affx_fusionc::GenericData_Header;
*DataGroupCnt = *affx_fusionc::GenericData_DataGroupCnt;
*DataGroupNames = *affx_fusionc::GenericData_DataGroupNames;
*DataSetCnt = *affx_fusionc::GenericData_DataSetCnt;
*DataSetNames = *affx_fusionc::GenericData_DataSetNames;
*DataSet = *affx_fusionc::GenericData_DataSet;
*DataGroup = *affx_fusionc::GenericData_DataGroup;
*Clear = *affx_fusionc::GenericData_Clear;
*ReadFullDataSetHeader = *affx_fusionc::GenericData_ReadFullDataSetHeader;
*IsDPHPartiallyRead = *affx_fusionc::GenericData_IsDPHPartiallyRead;
*OpenFStream = *affx_fusionc::GenericData_OpenFStream;
*FindDataGroupHeader = *affx_fusionc::GenericData_FindDataGroupHeader;
*FindDataSetHeader = *affx_fusionc::GenericData_FindDataSetHeader;
*MapFile = *affx_fusionc::GenericData_MapFile;
*UnmapFile = *affx_fusionc::GenericData_UnmapFile;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::GenericDataHeader ##############

package affx_fusion::GenericDataHeader;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_GenericDataHeader(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_GenericDataHeader($self);
        delete $OWNER{$self};
    }
}

*Clear = *affx_fusionc::GenericDataHeader_Clear;
*SetFileTypeId = *affx_fusionc::GenericDataHeader_SetFileTypeId;
*GetFileTypeId = *affx_fusionc::GenericDataHeader_GetFileTypeId;
*SetFileId = *affx_fusionc::GenericDataHeader_SetFileId;
*GetFileId = *affx_fusionc::GenericDataHeader_GetFileId;
*SetFileCreationTime = *affx_fusionc::GenericDataHeader_SetFileCreationTime;
*GetFileCreationTime = *affx_fusionc::GenericDataHeader_GetFileCreationTime;
*SetLocale = *affx_fusionc::GenericDataHeader_SetLocale;
*GetLocale = *affx_fusionc::GenericDataHeader_GetLocale;
*AddNameValParam = *affx_fusionc::GenericDataHeader_AddNameValParam;
*GetNameValParam = *affx_fusionc::GenericDataHeader_GetNameValParam;
*GetNameValParamCnt = *affx_fusionc::GenericDataHeader_GetNameValParamCnt;
*GetNameValIterators = *affx_fusionc::GenericDataHeader_GetNameValIterators;
*GetParentCnt = *affx_fusionc::GenericDataHeader_GetParentCnt;
*AddParent = *affx_fusionc::GenericDataHeader_AddParent;
*GetParent = *affx_fusionc::GenericDataHeader_GetParent;
*GetParentIterators = *affx_fusionc::GenericDataHeader_GetParentIterators;
*FindNameValParam = *affx_fusionc::GenericDataHeader_FindNameValParam;
*GetNameValParamsBeginsWith = *affx_fusionc::GenericDataHeader_GetNameValParamsBeginsWith;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::ArrayFileReader ##############

package affx_fusion::ArrayFileReader;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_ArrayFileReader(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_ArrayFileReader($self);
        delete $OWNER{$self};
    }
}

*Read = *affx_fusionc::ArrayFileReader_Read;
*IsFileType = *affx_fusionc::ArrayFileReader_IsFileType;
*DataTypeIdentifier = *affx_fusionc::ArrayFileReader_DataTypeIdentifier;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::AuditFileReader ##############

package affx_fusion::AuditFileReader;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_AuditFileReader(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_AuditFileReader($self);
        delete $OWNER{$self};
    }
}

*Read = *affx_fusionc::AuditFileReader_Read;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::CDFFileReader ##############

package affx_fusion::CDFFileReader;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
*ReadSequential = *affx_fusionc::CDFFileReader_ReadSequential;
*ReadByProbeSetNumber = *affx_fusionc::CDFFileReader_ReadByProbeSetNumber;
*ReadByProbeSetName = *affx_fusionc::CDFFileReader_ReadByProbeSetName;
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_CDFFileReader(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_CDFFileReader($self);
        delete $OWNER{$self};
    }
}

*GetFilename = *affx_fusionc::CDFFileReader_GetFilename;
*SetFilename = *affx_fusionc::CDFFileReader_SetFilename;
*Read = *affx_fusionc::CDFFileReader_Read;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::CHPFileReader ##############

package affx_fusion::CHPFileReader;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_CHPFileReader(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_CHPFileReader($self);
        delete $OWNER{$self};
    }
}

*GetFilename = *affx_fusionc::CHPFileReader_GetFilename;
*SetFilename = *affx_fusionc::CHPFileReader_SetFilename;
*Read = *affx_fusionc::CHPFileReader_Read;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::CelFileReader ##############

package affx_fusion::CelFileReader;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_CelFileReader(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_CelFileReader($self);
        delete $OWNER{$self};
    }
}

*GetFilename = *affx_fusionc::CelFileReader_GetFilename;
*SetFilename = *affx_fusionc::CelFileReader_SetFilename;
*Read = *affx_fusionc::CelFileReader_Read;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::DataGroupHeaderReader ##############

package affx_fusion::DataGroupHeaderReader;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_DataGroupHeaderReader(@_);
    bless $self, $pkg if defined($self);
}

*ReadAllMinimumInfo = *affx_fusionc::DataGroupHeaderReader_ReadAllMinimumInfo;
*ReadAll = *affx_fusionc::DataGroupHeaderReader_ReadAll;
*ReadMinimumInfo = *affx_fusionc::DataGroupHeaderReader_ReadMinimumInfo;
*Read = *affx_fusionc::DataGroupHeaderReader_Read;
*ReadHeader = *affx_fusionc::DataGroupHeaderReader_ReadHeader;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_DataGroupHeaderReader($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::DataGroupReader ##############

package affx_fusion::DataGroupReader;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_DataGroupReader(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_DataGroupReader($self);
        delete $OWNER{$self};
    }
}

*GetDataSetCnt = *affx_fusionc::DataGroupReader_GetDataSetCnt;
*GetDataGroupName = *affx_fusionc::DataGroupReader_GetDataGroupName;
*GetDataSetReader = *affx_fusionc::DataGroupReader_GetDataSetReader;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::DataSetHeaderReader ##############

package affx_fusion::DataSetHeaderReader;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_DataSetHeaderReader(@_);
    bless $self, $pkg if defined($self);
}

*ReadAllMinimumInfo = *affx_fusionc::DataSetHeaderReader_ReadAllMinimumInfo;
*ReadAll = *affx_fusionc::DataSetHeaderReader_ReadAll;
*ReadMinimumInfo = *affx_fusionc::DataSetHeaderReader_ReadMinimumInfo;
*Read = *affx_fusionc::DataSetHeaderReader_Read;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_DataSetHeaderReader($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::DataSetReader ##############

package affx_fusion::DataSetReader;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_DataSetReader(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_DataSetReader($self);
        delete $OWNER{$self};
    }
}

*GetDataSetName = *affx_fusionc::DataSetReader_GetDataSetName;
*GetDataSetHeader = *affx_fusionc::DataSetReader_GetDataSetHeader;
*Read = *affx_fusionc::DataSetReader_Read;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::FileNotFoundException ##############

package affx_fusion::FileNotFoundException;
@ISA = qw( affx_fusion affx_fusion::CalvinException );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_FileNotFoundException(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_FileNotFoundException($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::InvalidVersionException ##############

package affx_fusion::InvalidVersionException;
@ISA = qw( affx_fusion affx_fusion::CalvinException );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_InvalidVersionException(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_InvalidVersionException($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::InvalidFileTypeException ##############

package affx_fusion::InvalidFileTypeException;
@ISA = qw( affx_fusion affx_fusion::CalvinException );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_InvalidFileTypeException(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_InvalidFileTypeException($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::UnableToOpenFileException ##############

package affx_fusion::UnableToOpenFileException;
@ISA = qw( affx_fusion affx_fusion::CalvinException );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_UnableToOpenFileException(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_UnableToOpenFileException($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::FileNotOpenException ##############

package affx_fusion::FileNotOpenException;
@ISA = qw( affx_fusion affx_fusion::CalvinException );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_FileNotOpenException(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_FileNotOpenException($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::FileHeaderReader ##############

package affx_fusion::FileHeaderReader;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_FileHeaderReader(@_);
    bless $self, $pkg if defined($self);
}

*Read = *affx_fusionc::FileHeaderReader_Read;
*GetDataGroupCnt = *affx_fusionc::FileHeaderReader_GetDataGroupCnt;
*GetFirstDataGroupFilePos = *affx_fusionc::FileHeaderReader_GetFirstDataGroupFilePos;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_FileHeaderReader($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::FileInput ##############

package affx_fusion::FileInput;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
*ReadInt8 = *affx_fusionc::FileInput_ReadInt8;
*ReadInt16 = *affx_fusionc::FileInput_ReadInt16;
*ReadInt32 = *affx_fusionc::FileInput_ReadInt32;
*ReadUInt8 = *affx_fusionc::FileInput_ReadUInt8;
*ReadUInt16 = *affx_fusionc::FileInput_ReadUInt16;
*ReadUInt32 = *affx_fusionc::FileInput_ReadUInt32;
*ReadFloat = *affx_fusionc::FileInput_ReadFloat;
*ReadString16 = *affx_fusionc::FileInput_ReadString16;
*ReadString8 = *affx_fusionc::FileInput_ReadString8;
*ReadBlob = *affx_fusionc::FileInput_ReadBlob;
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_FileInput(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_FileInput($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::GenericDataHeaderReader ##############

package affx_fusion::GenericDataHeaderReader;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_GenericDataHeaderReader(@_);
    bless $self, $pkg if defined($self);
}

*Read = *affx_fusionc::GenericDataHeaderReader_Read;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_GenericDataHeaderReader($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::GenericFileReader ##############

package affx_fusion::GenericFileReader;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_GenericFileReader(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_GenericFileReader($self);
        delete $OWNER{$self};
    }
}

*All = *affx_fusionc::GenericFileReader_All;
*Sequential = *affx_fusionc::GenericFileReader_Sequential;
*None = *affx_fusionc::GenericFileReader_None;
*ReadAllHeaders = *affx_fusionc::GenericFileReader_ReadAllHeaders;
*ReadMinDataGroupHeader = *affx_fusionc::GenericFileReader_ReadMinDataGroupHeader;
*ReadNoDataGroupHeader = *affx_fusionc::GenericFileReader_ReadNoDataGroupHeader;
*GetFilename = *affx_fusionc::GenericFileReader_GetFilename;
*SetFilename = *affx_fusionc::GenericFileReader_SetFilename;
*ReadHeader = *affx_fusionc::GenericFileReader_ReadHeader;
*Open = *affx_fusionc::GenericFileReader_Open;
*GetDataGroupCnt = *affx_fusionc::GenericFileReader_GetDataGroupCnt;
*GetDataGroupReader = *affx_fusionc::GenericFileReader_GetDataGroupReader;
*Close = *affx_fusionc::GenericFileReader_Close;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::GridControlFileReader ##############

package affx_fusion::GridControlFileReader;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_GridControlFileReader(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_GridControlFileReader($self);
        delete $OWNER{$self};
    }
}

*Read = *affx_fusionc::GridControlFileReader_Read;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::TemplateFileReader ##############

package affx_fusion::TemplateFileReader;
@ISA = qw( affx_fusion affx_fusion::ArrayFileReader );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_TemplateFileReader(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_TemplateFileReader($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::TextFileReader ##############

package affx_fusion::TextFileReader;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_TextFileReader(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_TextFileReader($self);
        delete $OWNER{$self};
    }
}

*ReadFile = *affx_fusionc::TextFileReader_ReadFile;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::TemplateData ##############

package affx_fusion::TemplateData;
@ISA = qw( affx_fusion affx_fusion::ArrayData );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_TemplateData(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_TemplateData($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::CoordinatePoint ##############

package affx_fusion::CoordinatePoint;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
*swig_x_get = *affx_fusionc::CoordinatePoint_x_get;
*swig_x_set = *affx_fusionc::CoordinatePoint_x_set;
*swig_y_get = *affx_fusionc::CoordinatePoint_y_get;
*swig_y_set = *affx_fusionc::CoordinatePoint_y_set;
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_CoordinatePoint(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_CoordinatePoint($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::GridCoordinatesType ##############

package affx_fusion::GridCoordinatesType;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
*swig_upperleft_get = *affx_fusionc::GridCoordinatesType_upperleft_get;
*swig_upperleft_set = *affx_fusionc::GridCoordinatesType_upperleft_set;
*swig_upperright_get = *affx_fusionc::GridCoordinatesType_upperright_get;
*swig_upperright_set = *affx_fusionc::GridCoordinatesType_upperright_set;
*swig_lowerright_get = *affx_fusionc::GridCoordinatesType_lowerright_get;
*swig_lowerright_set = *affx_fusionc::GridCoordinatesType_lowerright_set;
*swig_lowerleft_get = *affx_fusionc::GridCoordinatesType_lowerleft_get;
*swig_lowerleft_set = *affx_fusionc::GridCoordinatesType_lowerleft_set;
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_GridCoordinatesType(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_GridCoordinatesType($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::TagValuePairType ##############

package affx_fusion::TagValuePairType;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
*swig_Tag_get = *affx_fusionc::TagValuePairType_Tag_get;
*swig_Tag_set = *affx_fusionc::TagValuePairType_Tag_set;
*swig_Value_get = *affx_fusionc::TagValuePairType_Value_get;
*swig_Value_set = *affx_fusionc::TagValuePairType_Value_set;
*_TagValuePairType_assign = *affx_fusionc::TagValuePairType__TagValuePairType_assign;
*_TagValuePairType_equals_obj = *affx_fusionc::TagValuePairType__TagValuePairType_equals_obj;
*_TagValuePairType_equals_tag = *affx_fusionc::TagValuePairType__TagValuePairType_equals_tag;
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_TagValuePairType(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_TagValuePairType($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::CCDFFileHeader ##############

package affx_fusion::CCDFFileHeader;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
*GetCols = *affx_fusionc::CCDFFileHeader_GetCols;
*GetRows = *affx_fusionc::CCDFFileHeader_GetRows;
*GetNumProbeSets = *affx_fusionc::CCDFFileHeader_GetNumProbeSets;
*GetNumQCProbeSets = *affx_fusionc::CCDFFileHeader_GetNumQCProbeSets;
*GetReference = *affx_fusionc::CCDFFileHeader_GetReference;
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_CCDFFileHeader(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_CCDFFileHeader($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::CCDFProbeInformation ##############

package affx_fusion::CCDFProbeInformation;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
*GetListIndex = *affx_fusionc::CCDFProbeInformation_GetListIndex;
*GetExpos = *affx_fusionc::CCDFProbeInformation_GetExpos;
*GetX = *affx_fusionc::CCDFProbeInformation_GetX;
*GetY = *affx_fusionc::CCDFProbeInformation_GetY;
*GetPBase = *affx_fusionc::CCDFProbeInformation_GetPBase;
*GetTBase = *affx_fusionc::CCDFProbeInformation_GetTBase;
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_CCDFProbeInformation(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_CCDFProbeInformation($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::CCDFProbeGroupInformation ##############

package affx_fusion::CCDFProbeGroupInformation;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
*GetDirection = *affx_fusionc::CCDFProbeGroupInformation_GetDirection;
*GetNumLists = *affx_fusionc::CCDFProbeGroupInformation_GetNumLists;
*GetNumCells = *affx_fusionc::CCDFProbeGroupInformation_GetNumCells;
*GetNumCellsPerList = *affx_fusionc::CCDFProbeGroupInformation_GetNumCellsPerList;
*GetStart = *affx_fusionc::CCDFProbeGroupInformation_GetStart;
*GetStop = *affx_fusionc::CCDFProbeGroupInformation_GetStop;
*GetName = *affx_fusionc::CCDFProbeGroupInformation_GetName;
*GetCell = *affx_fusionc::CCDFProbeGroupInformation_GetCell;
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_CCDFProbeGroupInformation(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_CCDFProbeGroupInformation($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::CCDFProbeSetInformation ##############

package affx_fusion::CCDFProbeSetInformation;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
*GetProbeSetType = *affx_fusionc::CCDFProbeSetInformation_GetProbeSetType;
*GetDirection = *affx_fusionc::CCDFProbeSetInformation_GetDirection;
*GetNumLists = *affx_fusionc::CCDFProbeSetInformation_GetNumLists;
*GetNumGroups = *affx_fusionc::CCDFProbeSetInformation_GetNumGroups;
*GetNumCells = *affx_fusionc::CCDFProbeSetInformation_GetNumCells;
*GetNumCellsPerList = *affx_fusionc::CCDFProbeSetInformation_GetNumCellsPerList;
*GetProbeSetNumber = *affx_fusionc::CCDFProbeSetInformation_GetProbeSetNumber;
*GetGroupInformation = *affx_fusionc::CCDFProbeSetInformation_GetGroupInformation;
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_CCDFProbeSetInformation(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_CCDFProbeSetInformation($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::CCDFProbeSetNames ##############

package affx_fusion::CCDFProbeSetNames;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_CCDFProbeSetNames(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_CCDFProbeSetNames($self);
        delete $OWNER{$self};
    }
}

*Clear = *affx_fusionc::CCDFProbeSetNames_Clear;
*GetName = *affx_fusionc::CCDFProbeSetNames_GetName;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::CCDFQCProbeInformation ##############

package affx_fusion::CCDFQCProbeInformation;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_CCDFQCProbeInformation(@_);
    bless $self, $pkg if defined($self);
}

*GetX = *affx_fusionc::CCDFQCProbeInformation_GetX;
*GetY = *affx_fusionc::CCDFQCProbeInformation_GetY;
*GetPLen = *affx_fusionc::CCDFQCProbeInformation_GetPLen;
*IsPerfectMatchProbe = *affx_fusionc::CCDFQCProbeInformation_IsPerfectMatchProbe;
*IsBackgroundProbe = *affx_fusionc::CCDFQCProbeInformation_IsBackgroundProbe;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_CCDFQCProbeInformation($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::CCDFQCProbeSetInformation ##############

package affx_fusion::CCDFQCProbeSetInformation;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
*GetQCProbeSetType = *affx_fusionc::CCDFQCProbeSetInformation_GetQCProbeSetType;
*GetNumCells = *affx_fusionc::CCDFQCProbeSetInformation_GetNumCells;
*GetProbeInformation = *affx_fusionc::CCDFQCProbeSetInformation_GetProbeInformation;
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_CCDFQCProbeSetInformation(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_CCDFQCProbeSetInformation($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::CCDFFileData ##############

package affx_fusion::CCDFFileData;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
*SetFileName = *affx_fusionc::CCDFFileData_SetFileName;
*GetFileName = *affx_fusionc::CCDFFileData_GetFileName;
*GetHeader = *affx_fusionc::CCDFFileData_GetHeader;
*GetError = *affx_fusionc::CCDFFileData_GetError;
*GetProbeSetName = *affx_fusionc::CCDFFileData_GetProbeSetName;
*GetChipType = *affx_fusionc::CCDFFileData_GetChipType;
*Read = *affx_fusionc::CCDFFileData_Read;
*ReadHeader = *affx_fusionc::CCDFFileData_ReadHeader;
*Exists = *affx_fusionc::CCDFFileData_Exists;
*Close = *affx_fusionc::CCDFFileData_Close;
*IsXDACompatibleFile = *affx_fusionc::CCDFFileData_IsXDACompatibleFile;
*GetProbeSetType = *affx_fusionc::CCDFFileData_GetProbeSetType;
*GetProbeSetInformation = *affx_fusionc::CCDFFileData_GetProbeSetInformation;
*GetQCProbeSetInformation = *affx_fusionc::CCDFFileData_GetQCProbeSetInformation;
*GetQCProbeSetInformation_By_Type = *affx_fusionc::CCDFFileData_GetQCProbeSetInformation_By_Type;
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_CCDFFileData(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_CCDFFileData($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::CELFileEntryType ##############

package affx_fusion::CELFileEntryType;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
*swig_Intensity_get = *affx_fusionc::CELFileEntryType_Intensity_get;
*swig_Intensity_set = *affx_fusionc::CELFileEntryType_Intensity_set;
*swig_Stdv_get = *affx_fusionc::CELFileEntryType_Stdv_get;
*swig_Stdv_set = *affx_fusionc::CELFileEntryType_Stdv_set;
*swig_Pixels_get = *affx_fusionc::CELFileEntryType_Pixels_get;
*swig_Pixels_set = *affx_fusionc::CELFileEntryType_Pixels_set;
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_CELFileEntryType(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_CELFileEntryType($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::CELFileTranscriptomeEntryType ##############

package affx_fusion::CELFileTranscriptomeEntryType;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
*swig_Intensity_get = *affx_fusionc::CELFileTranscriptomeEntryType_Intensity_get;
*swig_Intensity_set = *affx_fusionc::CELFileTranscriptomeEntryType_Intensity_set;
*swig_Stdv_get = *affx_fusionc::CELFileTranscriptomeEntryType_Stdv_get;
*swig_Stdv_set = *affx_fusionc::CELFileTranscriptomeEntryType_Stdv_set;
*swig_Pixels_get = *affx_fusionc::CELFileTranscriptomeEntryType_Pixels_get;
*swig_Pixels_set = *affx_fusionc::CELFileTranscriptomeEntryType_Pixels_set;
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_CELFileTranscriptomeEntryType(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_CELFileTranscriptomeEntryType($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::CCELFileHeaderData ##############

package affx_fusion::CCELFileHeaderData;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_CCELFileHeaderData(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_CCELFileHeaderData($self);
        delete $OWNER{$self};
    }
}

*Clear = *affx_fusionc::CCELFileHeaderData_Clear;
*SetMagic = *affx_fusionc::CCELFileHeaderData_SetMagic;
*GetMagic = *affx_fusionc::CCELFileHeaderData_GetMagic;
*SetVersion = *affx_fusionc::CCELFileHeaderData_SetVersion;
*GetVersion = *affx_fusionc::CCELFileHeaderData_GetVersion;
*SetCols = *affx_fusionc::CCELFileHeaderData_SetCols;
*GetCols = *affx_fusionc::CCELFileHeaderData_GetCols;
*SetRows = *affx_fusionc::CCELFileHeaderData_SetRows;
*GetRows = *affx_fusionc::CCELFileHeaderData_GetRows;
*SetCells = *affx_fusionc::CCELFileHeaderData_SetCells;
*GetCells = *affx_fusionc::CCELFileHeaderData_GetCells;
*AppendHeader = *affx_fusionc::CCELFileHeaderData_AppendHeader;
*SetHeader = *affx_fusionc::CCELFileHeaderData_SetHeader;
*GetHeader = *affx_fusionc::CCELFileHeaderData_GetHeader;
*SetAlg = *affx_fusionc::CCELFileHeaderData_SetAlg;
*GetAlg = *affx_fusionc::CCELFileHeaderData_GetAlg;
*SetParams = *affx_fusionc::CCELFileHeaderData_SetParams;
*GetParams = *affx_fusionc::CCELFileHeaderData_GetParams;
*ParseChipType = *affx_fusionc::CCELFileHeaderData_ParseChipType;
*SetChipType = *affx_fusionc::CCELFileHeaderData_SetChipType;
*GetChipType = *affx_fusionc::CCELFileHeaderData_GetChipType;
*ParseDatHeader = *affx_fusionc::CCELFileHeaderData_ParseDatHeader;
*SetDatHeader = *affx_fusionc::CCELFileHeaderData_SetDatHeader;
*GetDatHeader = *affx_fusionc::CCELFileHeaderData_GetDatHeader;
*SetMargin = *affx_fusionc::CCELFileHeaderData_SetMargin;
*GetMargin = *affx_fusionc::CCELFileHeaderData_GetMargin;
*SetOutliers = *affx_fusionc::CCELFileHeaderData_SetOutliers;
*GetOutliers = *affx_fusionc::CCELFileHeaderData_GetOutliers;
*IncrementOutliers = *affx_fusionc::CCELFileHeaderData_IncrementOutliers;
*DecrementOutliers = *affx_fusionc::CCELFileHeaderData_DecrementOutliers;
*SetMasked = *affx_fusionc::CCELFileHeaderData_SetMasked;
*GetMasked = *affx_fusionc::CCELFileHeaderData_GetMasked;
*IncrementMasked = *affx_fusionc::CCELFileHeaderData_IncrementMasked;
*DecrementMasked = *affx_fusionc::CCELFileHeaderData_DecrementMasked;
*ParseAlgorithmParameters = *affx_fusionc::CCELFileHeaderData_ParseAlgorithmParameters;
*AddAlgorithmParameter = *affx_fusionc::CCELFileHeaderData_AddAlgorithmParameter;
*SetAlgorithmParameter = *affx_fusionc::CCELFileHeaderData_SetAlgorithmParameter;
*GetAlgorithmParameter = *affx_fusionc::CCELFileHeaderData_GetAlgorithmParameter;
*GetAlgorithmParameterTag = *affx_fusionc::CCELFileHeaderData_GetAlgorithmParameterTag;
*GetNumberAlgorithmParameters = *affx_fusionc::CCELFileHeaderData_GetNumberAlgorithmParameters;
*GetAlgorithmParameters = *affx_fusionc::CCELFileHeaderData_GetAlgorithmParameters;
*SetGridCorners = *affx_fusionc::CCELFileHeaderData_SetGridCorners;
*ParseCorners = *affx_fusionc::CCELFileHeaderData_ParseCorners;
*GetGridCorners = *affx_fusionc::CCELFileHeaderData_GetGridCorners;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::CCELFileData ##############

package affx_fusion::CCELFileData;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
*TEXT_CEL = *affx_fusionc::CCELFileData_TEXT_CEL;
*XDA_BCEL = *affx_fusionc::CCELFileData_XDA_BCEL;
*TRANSCRIPTOME_BCEL = *affx_fusionc::CCELFileData_TRANSCRIPTOME_BCEL;
*COMPACT_BCEL = *affx_fusionc::CCELFileData_COMPACT_BCEL;
*CEL_ALL = *affx_fusionc::CCELFileData_CEL_ALL;
*CEL_DATA = *affx_fusionc::CCELFileData_CEL_DATA;
*CEL_OUTLIER = *affx_fusionc::CCELFileData_CEL_OUTLIER;
*CEL_MASK = *affx_fusionc::CCELFileData_CEL_MASK;
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_CCELFileData(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_CCELFileData($self);
        delete $OWNER{$self};
    }
}

*SetError = *affx_fusionc::CCELFileData_SetError;
*GetError = *affx_fusionc::CCELFileData_GetError;
*GetThisPtr = *affx_fusionc::CCELFileData_GetThisPtr;
*SetFileName = *affx_fusionc::CCELFileData_SetFileName;
*GetFileName = *affx_fusionc::CCELFileData_GetFileName;
*GetHeaderKey = *affx_fusionc::CCELFileData_GetHeaderKey;
*GetVersion = *affx_fusionc::CCELFileData_GetVersion;
*GetCols = *affx_fusionc::CCELFileData_GetCols;
*GetRows = *affx_fusionc::CCELFileData_GetRows;
*GetNumCells = *affx_fusionc::CCELFileData_GetNumCells;
*GetHeaderString = *affx_fusionc::CCELFileData_GetHeaderString;
*GetHeader = *affx_fusionc::CCELFileData_GetHeader;
*GetAlg = *affx_fusionc::CCELFileData_GetAlg;
*GetParams = *affx_fusionc::CCELFileData_GetParams;
*GetAlgorithmParameter = *affx_fusionc::CCELFileData_GetAlgorithmParameter;
*GetAlgorithmParameterTag = *affx_fusionc::CCELFileData_GetAlgorithmParameterTag;
*GetNumberAlgorithmParameters = *affx_fusionc::CCELFileData_GetNumberAlgorithmParameters;
*GetAlgorithmParameters = *affx_fusionc::CCELFileData_GetAlgorithmParameters;
*GetDatHeader = *affx_fusionc::CCELFileData_GetDatHeader;
*GetChipType = *affx_fusionc::CCELFileData_GetChipType;
*GetCellMargin = *affx_fusionc::CCELFileData_GetCellMargin;
*GetNumOutliers = *affx_fusionc::CCELFileData_GetNumOutliers;
*GetNumMasked = *affx_fusionc::CCELFileData_GetNumMasked;
*GetGridCorners = *affx_fusionc::CCELFileData_GetGridCorners;
*IndexToX = *affx_fusionc::CCELFileData_IndexToX;
*IndexToY = *affx_fusionc::CCELFileData_IndexToY;
*XYToIndex = *affx_fusionc::CCELFileData_XYToIndex;
*GetEntry = *affx_fusionc::CCELFileData_GetEntry;
*GetTranscriptomeEntry = *affx_fusionc::CCELFileData_GetTranscriptomeEntry;
*GetIntensity = *affx_fusionc::CCELFileData_GetIntensity;
*GetStdv = *affx_fusionc::CCELFileData_GetStdv;
*GetPixels = *affx_fusionc::CCELFileData_GetPixels;
*IsMasked = *affx_fusionc::CCELFileData_IsMasked;
*IsOutlier = *affx_fusionc::CCELFileData_IsOutlier;
*Close = *affx_fusionc::CCELFileData_Close;
*GetFileSize = *affx_fusionc::CCELFileData_GetFileSize;
*Exists = *affx_fusionc::CCELFileData_Exists;
*ReadHeader = *affx_fusionc::CCELFileData_ReadHeader;
*Read = *affx_fusionc::CCELFileData_Read;
*IsXDACompatibleFile = *affx_fusionc::CCELFileData_IsXDACompatibleFile;
*IsTranscriptomeBcelFile = *affx_fusionc::CCELFileData_IsTranscriptomeBcelFile;
*IsCompactCelFile = *affx_fusionc::CCELFileData_IsCompactCelFile;
*ReadEx = *affx_fusionc::CCELFileData_ReadEx;
*GetReadState = *affx_fusionc::CCELFileData_GetReadState;
*Clear = *affx_fusionc::CCELFileData_Clear;
*GetFileFormat = *affx_fusionc::CCELFileData_GetFileFormat;
*SetFileFormat = *affx_fusionc::CCELFileData_SetFileFormat;
*SetAlgorithmName = *affx_fusionc::CCELFileData_SetAlgorithmName;
*AddAlgorithmParameter = *affx_fusionc::CCELFileData_AddAlgorithmParameter;
*SetDimensions = *affx_fusionc::CCELFileData_SetDimensions;
*SetChipType = *affx_fusionc::CCELFileData_SetChipType;
*SetMargin = *affx_fusionc::CCELFileData_SetMargin;
*SetGridCorners = *affx_fusionc::CCELFileData_SetGridCorners;
*SetCellEntry = *affx_fusionc::CCELFileData_SetCellEntry;
*AllocateEntries = *affx_fusionc::CCELFileData_AllocateEntries;
*SetTranscriptomeCellEntry = *affx_fusionc::CCELFileData_SetTranscriptomeCellEntry;
*AllocateTranscriptomeEntries = *affx_fusionc::CCELFileData_AllocateTranscriptomeEntries;
*SetIntensity = *affx_fusionc::CCELFileData_SetIntensity;
*SetStdv = *affx_fusionc::CCELFileData_SetStdv;
*SetPixels = *affx_fusionc::CCELFileData_SetPixels;
*SetMask = *affx_fusionc::CCELFileData_SetMask;
*SetOutlier = *affx_fusionc::CCELFileData_SetOutlier;
*Munmap = *affx_fusionc::CCELFileData_Munmap;
*EnsureNotMmapped = *affx_fusionc::CCELFileData_EnsureNotMmapped;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::BackgroundZoneType ##############

package affx_fusion::BackgroundZoneType;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
*swig_centerx_get = *affx_fusionc::BackgroundZoneType_centerx_get;
*swig_centerx_set = *affx_fusionc::BackgroundZoneType_centerx_set;
*swig_centery_get = *affx_fusionc::BackgroundZoneType_centery_get;
*swig_centery_set = *affx_fusionc::BackgroundZoneType_centery_set;
*swig_background_get = *affx_fusionc::BackgroundZoneType_background_get;
*swig_background_set = *affx_fusionc::BackgroundZoneType_background_set;
*_BackgroundZoneType_assign = *affx_fusionc::BackgroundZoneType__BackgroundZoneType_assign;
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_BackgroundZoneType(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_BackgroundZoneType($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::BackgroundZoneInfo ##############

package affx_fusion::BackgroundZoneInfo;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
*swig_number_zones_get = *affx_fusionc::BackgroundZoneInfo_number_zones_get;
*swig_number_zones_set = *affx_fusionc::BackgroundZoneInfo_number_zones_set;
*swig_smooth_factor_get = *affx_fusionc::BackgroundZoneInfo_smooth_factor_get;
*swig_smooth_factor_set = *affx_fusionc::BackgroundZoneInfo_smooth_factor_set;
*swig_zones_get = *affx_fusionc::BackgroundZoneInfo_zones_get;
*swig_zones_set = *affx_fusionc::BackgroundZoneInfo_zones_set;
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_BackgroundZoneInfo(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_BackgroundZoneInfo($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::CCHPFileHeader ##############

package affx_fusion::CCHPFileHeader;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_CCHPFileHeader(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_CCHPFileHeader($self);
        delete $OWNER{$self};
    }
}

*Expression = *affx_fusionc::CCHPFileHeader_Expression;
*Genotyping = *affx_fusionc::CCHPFileHeader_Genotyping;
*Resequencing = *affx_fusionc::CCHPFileHeader_Resequencing;
*Universal = *affx_fusionc::CCHPFileHeader_Universal;
*Unknown = *affx_fusionc::CCHPFileHeader_Unknown;
*GetCols = *affx_fusionc::CCHPFileHeader_GetCols;
*GetRows = *affx_fusionc::CCHPFileHeader_GetRows;
*GetNumProbeSets = *affx_fusionc::CCHPFileHeader_GetNumProbeSets;
*GetAssayType = *affx_fusionc::CCHPFileHeader_GetAssayType;
*GetChipType = *affx_fusionc::CCHPFileHeader_GetChipType;
*GetAlgName = *affx_fusionc::CCHPFileHeader_GetAlgName;
*GetAlgVersion = *affx_fusionc::CCHPFileHeader_GetAlgVersion;
*AlgorithmParameters = *affx_fusionc::CCHPFileHeader_AlgorithmParameters;
*SummaryParameters = *affx_fusionc::CCHPFileHeader_SummaryParameters;
*GetParentCellFile = *affx_fusionc::CCHPFileHeader_GetParentCellFile;
*GetProgID = *affx_fusionc::CCHPFileHeader_GetProgID;
*GetAlgorithmParameter = *affx_fusionc::CCHPFileHeader_GetAlgorithmParameter;
*GetSummaryParameter = *affx_fusionc::CCHPFileHeader_GetSummaryParameter;
*GetBackgroundZoneInfo = *affx_fusionc::CCHPFileHeader_GetBackgroundZoneInfo;
*GetBackgroundZones = *affx_fusionc::CCHPFileHeader_GetBackgroundZones;
*GetBackgroundZone = *affx_fusionc::CCHPFileHeader_GetBackgroundZone;
*GetMagicNumber = *affx_fusionc::CCHPFileHeader_GetMagicNumber;
*GetVersionNumber = *affx_fusionc::CCHPFileHeader_GetVersionNumber;
*SetCols = *affx_fusionc::CCHPFileHeader_SetCols;
*SetRows = *affx_fusionc::CCHPFileHeader_SetRows;
*SetNumProbeSets = *affx_fusionc::CCHPFileHeader_SetNumProbeSets;
*SetAssayType = *affx_fusionc::CCHPFileHeader_SetAssayType;
*SetChipType = *affx_fusionc::CCHPFileHeader_SetChipType;
*SetAlgName = *affx_fusionc::CCHPFileHeader_SetAlgName;
*SetAlgVersion = *affx_fusionc::CCHPFileHeader_SetAlgVersion;
*SetParentCellFile = *affx_fusionc::CCHPFileHeader_SetParentCellFile;
*SetProgID = *affx_fusionc::CCHPFileHeader_SetProgID;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::CProbeSetResults ##############

package affx_fusion::CProbeSetResults;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_CProbeSetResults(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_CProbeSetResults($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::CExpressionProbeSetResults ##############

package affx_fusion::CExpressionProbeSetResults;
@ISA = qw( affx_fusion affx_fusion::CProbeSetResults );
%OWNER = ();
%ITERATORS = ();
*swig_DetectionPValue_get = *affx_fusionc::CExpressionProbeSetResults_DetectionPValue_get;
*swig_DetectionPValue_set = *affx_fusionc::CExpressionProbeSetResults_DetectionPValue_set;
*swig_Signal_get = *affx_fusionc::CExpressionProbeSetResults_Signal_get;
*swig_Signal_set = *affx_fusionc::CExpressionProbeSetResults_Signal_set;
*swig_NumPairs_get = *affx_fusionc::CExpressionProbeSetResults_NumPairs_get;
*swig_NumPairs_set = *affx_fusionc::CExpressionProbeSetResults_NumPairs_set;
*swig_NumUsedPairs_get = *affx_fusionc::CExpressionProbeSetResults_NumUsedPairs_get;
*swig_NumUsedPairs_set = *affx_fusionc::CExpressionProbeSetResults_NumUsedPairs_set;
*swig_Detection_get = *affx_fusionc::CExpressionProbeSetResults_Detection_get;
*swig_Detection_set = *affx_fusionc::CExpressionProbeSetResults_Detection_set;
*swig_m_HasCompResults_get = *affx_fusionc::CExpressionProbeSetResults_m_HasCompResults_get;
*swig_m_HasCompResults_set = *affx_fusionc::CExpressionProbeSetResults_m_HasCompResults_set;
*swig_ChangePValue_get = *affx_fusionc::CExpressionProbeSetResults_ChangePValue_get;
*swig_ChangePValue_set = *affx_fusionc::CExpressionProbeSetResults_ChangePValue_set;
*swig_SignalLogRatio_get = *affx_fusionc::CExpressionProbeSetResults_SignalLogRatio_get;
*swig_SignalLogRatio_set = *affx_fusionc::CExpressionProbeSetResults_SignalLogRatio_set;
*swig_SignalLogRatioLow_get = *affx_fusionc::CExpressionProbeSetResults_SignalLogRatioLow_get;
*swig_SignalLogRatioLow_set = *affx_fusionc::CExpressionProbeSetResults_SignalLogRatioLow_set;
*swig_SignalLogRatioHigh_get = *affx_fusionc::CExpressionProbeSetResults_SignalLogRatioHigh_get;
*swig_SignalLogRatioHigh_set = *affx_fusionc::CExpressionProbeSetResults_SignalLogRatioHigh_set;
*swig_NumCommonPairs_get = *affx_fusionc::CExpressionProbeSetResults_NumCommonPairs_get;
*swig_NumCommonPairs_set = *affx_fusionc::CExpressionProbeSetResults_NumCommonPairs_set;
*swig_Change_get = *affx_fusionc::CExpressionProbeSetResults_Change_get;
*swig_Change_set = *affx_fusionc::CExpressionProbeSetResults_Change_set;
*GetDetectionString = *affx_fusionc::CExpressionProbeSetResults_GetDetectionString;
*GetChangeString = *affx_fusionc::CExpressionProbeSetResults_GetChangeString;
*CExpressionProbeSetResults_assign = *affx_fusionc::CExpressionProbeSetResults_CExpressionProbeSetResults_assign;
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_CExpressionProbeSetResults(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_CExpressionProbeSetResults($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::CGenotypeProbeSetResults ##############

package affx_fusion::CGenotypeProbeSetResults;
@ISA = qw( affx_fusion affx_fusion::CProbeSetResults );
%OWNER = ();
%ITERATORS = ();
*swig_AlleleCall_get = *affx_fusionc::CGenotypeProbeSetResults_AlleleCall_get;
*swig_AlleleCall_set = *affx_fusionc::CGenotypeProbeSetResults_AlleleCall_set;
*swig_Confidence_get = *affx_fusionc::CGenotypeProbeSetResults_Confidence_get;
*swig_Confidence_set = *affx_fusionc::CGenotypeProbeSetResults_Confidence_set;
*swig_RAS1_get = *affx_fusionc::CGenotypeProbeSetResults_RAS1_get;
*swig_RAS1_set = *affx_fusionc::CGenotypeProbeSetResults_RAS1_set;
*swig_RAS2_get = *affx_fusionc::CGenotypeProbeSetResults_RAS2_get;
*swig_RAS2_set = *affx_fusionc::CGenotypeProbeSetResults_RAS2_set;
*swig_pvalue_AA_get = *affx_fusionc::CGenotypeProbeSetResults_pvalue_AA_get;
*swig_pvalue_AA_set = *affx_fusionc::CGenotypeProbeSetResults_pvalue_AA_set;
*swig_pvalue_AB_get = *affx_fusionc::CGenotypeProbeSetResults_pvalue_AB_get;
*swig_pvalue_AB_set = *affx_fusionc::CGenotypeProbeSetResults_pvalue_AB_set;
*swig_pvalue_BB_get = *affx_fusionc::CGenotypeProbeSetResults_pvalue_BB_get;
*swig_pvalue_BB_set = *affx_fusionc::CGenotypeProbeSetResults_pvalue_BB_set;
*swig_pvalue_NoCall_get = *affx_fusionc::CGenotypeProbeSetResults_pvalue_NoCall_get;
*swig_pvalue_NoCall_set = *affx_fusionc::CGenotypeProbeSetResults_pvalue_NoCall_set;
*GetAlleleCallString = *affx_fusionc::CGenotypeProbeSetResults_GetAlleleCallString;
*CGenotypeProbeSetResults_assign = *affx_fusionc::CGenotypeProbeSetResults_CGenotypeProbeSetResults_assign;
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_CGenotypeProbeSetResults(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_CGenotypeProbeSetResults($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::CUniversalProbeSetResults ##############

package affx_fusion::CUniversalProbeSetResults;
@ISA = qw( affx_fusion affx_fusion::CProbeSetResults );
%OWNER = ();
%ITERATORS = ();
*GetBackground = *affx_fusionc::CUniversalProbeSetResults_GetBackground;
*SetBackground = *affx_fusionc::CUniversalProbeSetResults_SetBackground;
*CUniversalProbeSetResults_assign = *affx_fusionc::CUniversalProbeSetResults_CUniversalProbeSetResults_assign;
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_CUniversalProbeSetResults(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_CUniversalProbeSetResults($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::ForceCallType ##############

package affx_fusion::ForceCallType;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
*swig_position_get = *affx_fusionc::ForceCallType_position_get;
*swig_position_set = *affx_fusionc::ForceCallType_position_set;
*swig_call_get = *affx_fusionc::ForceCallType_call_get;
*swig_call_set = *affx_fusionc::ForceCallType_call_set;
*swig_reason_get = *affx_fusionc::ForceCallType_reason_get;
*swig_reason_set = *affx_fusionc::ForceCallType_reason_set;
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_ForceCallType(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_ForceCallType($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::BaseCallType ##############

package affx_fusion::BaseCallType;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
*swig_position_get = *affx_fusionc::BaseCallType_position_get;
*swig_position_set = *affx_fusionc::BaseCallType_position_set;
*swig_call_get = *affx_fusionc::BaseCallType_call_get;
*swig_call_set = *affx_fusionc::BaseCallType_call_set;
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_BaseCallType(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_BaseCallType($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::CResequencingResults ##############

package affx_fusion::CResequencingResults;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_CResequencingResults(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_CResequencingResults($self);
        delete $OWNER{$self};
    }
}

*Clear = *affx_fusionc::CResequencingResults_Clear;
*GetCalledBases = *affx_fusionc::CResequencingResults_GetCalledBases;
*GetCalledBase = *affx_fusionc::CResequencingResults_GetCalledBase;
*GetCalledBasesSize = *affx_fusionc::CResequencingResults_GetCalledBasesSize;
*ResizeCalledBases = *affx_fusionc::CResequencingResults_ResizeCalledBases;
*SetCalledBase = *affx_fusionc::CResequencingResults_SetCalledBase;
*GetScores = *affx_fusionc::CResequencingResults_GetScores;
*GetScore = *affx_fusionc::CResequencingResults_GetScore;
*GetScoresSize = *affx_fusionc::CResequencingResults_GetScoresSize;
*ResizeScores = *affx_fusionc::CResequencingResults_ResizeScores;
*SetScore = *affx_fusionc::CResequencingResults_SetScore;
*GetForceCalls = *affx_fusionc::CResequencingResults_GetForceCalls;
*GetForceCall = *affx_fusionc::CResequencingResults_GetForceCall;
*GetForceCallsSize = *affx_fusionc::CResequencingResults_GetForceCallsSize;
*ResizeForceCalls = *affx_fusionc::CResequencingResults_ResizeForceCalls;
*SetForceCall = *affx_fusionc::CResequencingResults_SetForceCall;
*GetOrigCalls = *affx_fusionc::CResequencingResults_GetOrigCalls;
*GetOrigCall = *affx_fusionc::CResequencingResults_GetOrigCall;
*GetOrigCallsSize = *affx_fusionc::CResequencingResults_GetOrigCallsSize;
*ResizeOrigCalls = *affx_fusionc::CResequencingResults_ResizeOrigCalls;
*SetOrigCall = *affx_fusionc::CResequencingResults_SetOrigCall;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::CCHPFileData ##############

package affx_fusion::CCHPFileData;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_CCHPFileData(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_CCHPFileData($self);
        delete $OWNER{$self};
    }
}

*GetHeader = *affx_fusionc::CCHPFileData_GetHeader;
*GetExpressionResults = *affx_fusionc::CCHPFileData_GetExpressionResults;
*GetGenotypingResults = *affx_fusionc::CCHPFileData_GetGenotypingResults;
*GetUniversalResults = *affx_fusionc::CCHPFileData_GetUniversalResults;
*GetResequencingResults = *affx_fusionc::CCHPFileData_GetResequencingResults;
*GetError = *affx_fusionc::CCHPFileData_GetError;
*Read = *affx_fusionc::CCHPFileData_Read;
*ReadHeader = *affx_fusionc::CCHPFileData_ReadHeader;
*Exists = *affx_fusionc::CCHPFileData_Exists;
*IsXDACompatibleFile = *affx_fusionc::CCHPFileData_IsXDACompatibleFile;
*SetFileName = *affx_fusionc::CCHPFileData_SetFileName;
*GetFileName = *affx_fusionc::CCHPFileData_GetFileName;
*Clear = *affx_fusionc::CCHPFileData_Clear;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::BarSequenceResultData ##############

package affx_fusion::BarSequenceResultData;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
*swig_dValue_get = *affx_fusionc::BarSequenceResultData_dValue_get;
*swig_dValue_set = *affx_fusionc::BarSequenceResultData_dValue_set;
*swig_fValue_get = *affx_fusionc::BarSequenceResultData_fValue_get;
*swig_fValue_set = *affx_fusionc::BarSequenceResultData_fValue_set;
*swig_iValue_get = *affx_fusionc::BarSequenceResultData_iValue_get;
*swig_iValue_set = *affx_fusionc::BarSequenceResultData_iValue_set;
*swig_sValue_get = *affx_fusionc::BarSequenceResultData_sValue_get;
*swig_sValue_set = *affx_fusionc::BarSequenceResultData_sValue_set;
*swig_cValue_get = *affx_fusionc::BarSequenceResultData_cValue_get;
*swig_cValue_set = *affx_fusionc::BarSequenceResultData_cValue_set;
*swig_uiValue_get = *affx_fusionc::BarSequenceResultData_uiValue_get;
*swig_uiValue_set = *affx_fusionc::BarSequenceResultData_uiValue_set;
*swig_usValue_get = *affx_fusionc::BarSequenceResultData_usValue_get;
*swig_usValue_set = *affx_fusionc::BarSequenceResultData_usValue_set;
*swig_ucValue_get = *affx_fusionc::BarSequenceResultData_ucValue_get;
*swig_ucValue_set = *affx_fusionc::BarSequenceResultData_ucValue_set;
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_BarSequenceResultData(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_BarSequenceResultData($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::CGDACSequenceResultItem ##############

package affx_fusion::CGDACSequenceResultItem;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_CGDACSequenceResultItem(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_CGDACSequenceResultItem($self);
        delete $OWNER{$self};
    }
}

*GetName = *affx_fusionc::CGDACSequenceResultItem_GetName;
*GetVersion = *affx_fusionc::CGDACSequenceResultItem_GetVersion;
*GetGroupName = *affx_fusionc::CGDACSequenceResultItem_GetGroupName;
*GetNumberDataPoints = *affx_fusionc::CGDACSequenceResultItem_GetNumberDataPoints;
*GetNumberColumns = *affx_fusionc::CGDACSequenceResultItem_GetNumberColumns;
*GetColumnType = *affx_fusionc::CGDACSequenceResultItem_GetColumnType;
*GetData = *affx_fusionc::CGDACSequenceResultItem_GetData;
*GetNumberParameters = *affx_fusionc::CGDACSequenceResultItem_GetNumberParameters;
*GetParameter = *affx_fusionc::CGDACSequenceResultItem_GetParameter;
*SetName = *affx_fusionc::CGDACSequenceResultItem_SetName;
*SetVersion = *affx_fusionc::CGDACSequenceResultItem_SetVersion;
*SetGroupName = *affx_fusionc::CGDACSequenceResultItem_SetGroupName;
*SetNumberDataPoints = *affx_fusionc::CGDACSequenceResultItem_SetNumberDataPoints;
*SetDataPoint = *affx_fusionc::CGDACSequenceResultItem_SetDataPoint;
*AddParameter = *affx_fusionc::CGDACSequenceResultItem_AddParameter;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::CBARFileData ##############

package affx_fusion::CBARFileData;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_CBARFileData(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_CBARFileData($self);
        delete $OWNER{$self};
    }
}

*SetFileName = *affx_fusionc::CBARFileData_SetFileName;
*GetFileName = *affx_fusionc::CBARFileData_GetFileName;
*Read = *affx_fusionc::CBARFileData_Read;
*ReadHeader = *affx_fusionc::CBARFileData_ReadHeader;
*Exists = *affx_fusionc::CBARFileData_Exists;
*Close = *affx_fusionc::CBARFileData_Close;
*GetError = *affx_fusionc::CBARFileData_GetError;
*GetVersion = *affx_fusionc::CBARFileData_GetVersion;
*GetNumberSequences = *affx_fusionc::CBARFileData_GetNumberSequences;
*GetNumberColumns = *affx_fusionc::CBARFileData_GetNumberColumns;
*GetNumberParameters = *affx_fusionc::CBARFileData_GetNumberParameters;
*GetParameter = *affx_fusionc::CBARFileData_GetParameter;
*GetColumnTypes = *affx_fusionc::CBARFileData_GetColumnTypes;
*GetResults = *affx_fusionc::CBARFileData_GetResults;
*AddAlgorithmParameter = *affx_fusionc::CBARFileData_AddAlgorithmParameter;
*AddColumn = *affx_fusionc::CBARFileData_AddColumn;
*SetNumberSequences = *affx_fusionc::CBARFileData_SetNumberSequences;
*GetResultsPtr = *affx_fusionc::CBARFileData_GetResultsPtr;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::GDACSequenceHitItemType ##############

package affx_fusion::GDACSequenceHitItemType;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
*swig_PMX_get = *affx_fusionc::GDACSequenceHitItemType_PMX_get;
*swig_PMX_set = *affx_fusionc::GDACSequenceHitItemType_PMX_set;
*swig_PMY_get = *affx_fusionc::GDACSequenceHitItemType_PMY_get;
*swig_PMY_set = *affx_fusionc::GDACSequenceHitItemType_PMY_set;
*swig_MMX_get = *affx_fusionc::GDACSequenceHitItemType_MMX_get;
*swig_MMX_set = *affx_fusionc::GDACSequenceHitItemType_MMX_set;
*swig_MMY_get = *affx_fusionc::GDACSequenceHitItemType_MMY_get;
*swig_MMY_set = *affx_fusionc::GDACSequenceHitItemType_MMY_set;
*swig_MatchScore_get = *affx_fusionc::GDACSequenceHitItemType_MatchScore_get;
*swig_MatchScore_set = *affx_fusionc::GDACSequenceHitItemType_MatchScore_set;
*swig_Position_get = *affx_fusionc::GDACSequenceHitItemType_Position_get;
*swig_Position_set = *affx_fusionc::GDACSequenceHitItemType_Position_set;
*swig_PMProbe_get = *affx_fusionc::GDACSequenceHitItemType_PMProbe_get;
*swig_PMProbe_set = *affx_fusionc::GDACSequenceHitItemType_PMProbe_set;
*swig_ProbeLength_get = *affx_fusionc::GDACSequenceHitItemType_ProbeLength_get;
*swig_ProbeLength_set = *affx_fusionc::GDACSequenceHitItemType_ProbeLength_set;
*swig_TopStrand_get = *affx_fusionc::GDACSequenceHitItemType_TopStrand_get;
*swig_TopStrand_set = *affx_fusionc::GDACSequenceHitItemType_TopStrand_set;
*_GDACSequenceHitItemType_less_than = *affx_fusionc::GDACSequenceHitItemType__GDACSequenceHitItemType_less_than;
*swig_PackedPMProbe_get = *affx_fusionc::GDACSequenceHitItemType_PackedPMProbe_get;
*swig_PackedPMProbe_set = *affx_fusionc::GDACSequenceHitItemType_PackedPMProbe_set;
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_GDACSequenceHitItemType(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_GDACSequenceHitItemType($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::CGDACSequenceItem ##############

package affx_fusion::CGDACSequenceItem;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_CGDACSequenceItem(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_CGDACSequenceItem($self);
        delete $OWNER{$self};
    }
}

*GetName = *affx_fusionc::CGDACSequenceItem_GetName;
*GroupName = *affx_fusionc::CGDACSequenceItem_GroupName;
*GetSeqVersion = *affx_fusionc::CGDACSequenceItem_GetSeqVersion;
*GetProbeMapping = *affx_fusionc::CGDACSequenceItem_GetProbeMapping;
*GetNumber = *affx_fusionc::CGDACSequenceItem_GetNumber;
*GetNumberHits = *affx_fusionc::CGDACSequenceItem_GetNumberHits;
*GetNumberParameters = *affx_fusionc::CGDACSequenceItem_GetNumberParameters;
*GetParameter = *affx_fusionc::CGDACSequenceItem_GetParameter;
*GetHitItem = *affx_fusionc::CGDACSequenceItem_GetHitItem;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::CBPMAPFileData ##############

package affx_fusion::CBPMAPFileData;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_CBPMAPFileData(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_CBPMAPFileData($self);
        delete $OWNER{$self};
    }
}

*SetFileName = *affx_fusionc::CBPMAPFileData_SetFileName;
*GetFileName = *affx_fusionc::CBPMAPFileData_GetFileName;
*Read = *affx_fusionc::CBPMAPFileData_Read;
*ReadHeader = *affx_fusionc::CBPMAPFileData_ReadHeader;
*Exists = *affx_fusionc::CBPMAPFileData_Exists;
*Close = *affx_fusionc::CBPMAPFileData_Close;
*GetError = *affx_fusionc::CBPMAPFileData_GetError;
*GetNumberSequences = *affx_fusionc::CBPMAPFileData_GetNumberSequences;
*GetVersion = *affx_fusionc::CBPMAPFileData_GetVersion;
*GetSequenceItem = *affx_fusionc::CBPMAPFileData_GetSequenceItem;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::CEXPFileData ##############

package affx_fusion::CEXPFileData;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_CEXPFileData(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_CEXPFileData($self);
        delete $OWNER{$self};
    }
}

*SetFileName = *affx_fusionc::CEXPFileData_SetFileName;
*GetFileName = *affx_fusionc::CEXPFileData_GetFileName;
*GetArrayType = *affx_fusionc::CEXPFileData_GetArrayType;
*SetArrayType = *affx_fusionc::CEXPFileData_SetArrayType;
*Read = *affx_fusionc::CEXPFileData_Read;
*Exists = *affx_fusionc::CEXPFileData_Exists;
*Clear = *affx_fusionc::CEXPFileData_Clear;
*GetScanParameters = *affx_fusionc::CEXPFileData_GetScanParameters;
*GetHybParameters = *affx_fusionc::CEXPFileData_GetHybParameters;
*GetSampleParameters = *affx_fusionc::CEXPFileData_GetSampleParameters;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::CGRCFileData ##############

package affx_fusion::CGRCFileData;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_CGRCFileData(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_CGRCFileData($self);
        delete $OWNER{$self};
    }
}

*SetFileName = *affx_fusionc::CGRCFileData_SetFileName;
*GetFileName = *affx_fusionc::CGRCFileData_GetFileName;
*Read = *affx_fusionc::CGRCFileData_Read;
*Exists = *affx_fusionc::CGRCFileData_Exists;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::ProbeSetIndiciesType ##############

package affx_fusion::ProbeSetIndiciesType;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
*swig_probeSetName_get = *affx_fusionc::ProbeSetIndiciesType_probeSetName_get;
*swig_probeSetName_set = *affx_fusionc::ProbeSetIndiciesType_probeSetName_set;
*swig_indicies_get = *affx_fusionc::ProbeSetIndiciesType_indicies_get;
*swig_indicies_set = *affx_fusionc::ProbeSetIndiciesType_indicies_set;
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_ProbeSetIndiciesType(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_ProbeSetIndiciesType($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::CMSKFileData ##############

package affx_fusion::CMSKFileData;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_CMSKFileData(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_CMSKFileData($self);
        delete $OWNER{$self};
    }
}

*SetFileName = *affx_fusionc::CMSKFileData_SetFileName;
*GetFileName = *affx_fusionc::CMSKFileData_GetFileName;
*GetArrayType = *affx_fusionc::CMSKFileData_GetArrayType;
*GetProbeSetIndiciesListCount = *affx_fusionc::CMSKFileData_GetProbeSetIndiciesListCount;
*GetProbeSetListCount = *affx_fusionc::CMSKFileData_GetProbeSetListCount;
*GetError = *affx_fusionc::CMSKFileData_GetError;
*GetProbeSetIndiciesIterators = *affx_fusionc::CMSKFileData_GetProbeSetIndiciesIterators;
*GetProbeSetIterators = *affx_fusionc::CMSKFileData_GetProbeSetIterators;
*Read = *affx_fusionc::CMSKFileData_Read;
*Exists = *affx_fusionc::CMSKFileData_Exists;
*Clear = *affx_fusionc::CMSKFileData_Clear;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::ProbeSetInfo ##############

package affx_fusion::ProbeSetInfo;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
*swig_probeSetName_get = *affx_fusionc::ProbeSetInfo_probeSetName_get;
*swig_probeSetName_set = *affx_fusionc::ProbeSetInfo_probeSetName_set;
*swig_numberPairs_get = *affx_fusionc::ProbeSetInfo_numberPairs_get;
*swig_numberPairs_set = *affx_fusionc::ProbeSetInfo_numberPairs_set;
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_ProbeSetInfo(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_ProbeSetInfo($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::CPSIFileData ##############

package affx_fusion::CPSIFileData;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_CPSIFileData(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_CPSIFileData($self);
        delete $OWNER{$self};
    }
}

*SetFileName = *affx_fusionc::CPSIFileData_SetFileName;
*GetFileName = *affx_fusionc::CPSIFileData_GetFileName;
*GetProbeSetCount = *affx_fusionc::CPSIFileData_GetProbeSetCount;
*GetProbeSetName = *affx_fusionc::CPSIFileData_GetProbeSetName;
*GetProbePairs = *affx_fusionc::CPSIFileData_GetProbePairs;
*Read = *affx_fusionc::CPSIFileData_Read;
*Exists = *affx_fusionc::CPSIFileData_Exists;
*Clear = *affx_fusionc::CPSIFileData_Clear;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::AttributeNameValueType ##############

package affx_fusion::AttributeNameValueType;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
*swig_name_get = *affx_fusionc::AttributeNameValueType_name_get;
*swig_name_set = *affx_fusionc::AttributeNameValueType_name_set;
*swig_value_get = *affx_fusionc::AttributeNameValueType_value_get;
*swig_value_set = *affx_fusionc::AttributeNameValueType_value_set;
*swig_type_get = *affx_fusionc::AttributeNameValueType_type_get;
*swig_type_set = *affx_fusionc::AttributeNameValueType_type_set;
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_AttributeNameValueType(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_AttributeNameValueType($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::DttArrayData ##############

package affx_fusion::DttArrayData;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_DttArrayData(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_DttArrayData($self);
        delete $OWNER{$self};
    }
}

*GetArrayType = *affx_fusionc::DttArrayData_GetArrayType;
*SetArrayType = *affx_fusionc::DttArrayData_SetArrayType;
*GetExperimentName = *affx_fusionc::DttArrayData_GetExperimentName;
*SetExperimentName = *affx_fusionc::DttArrayData_SetExperimentName;
*Attributes = *affx_fusionc::DttArrayData_Attributes;
*Clear = *affx_fusionc::DttArrayData_Clear;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::DttArrayFileReader ##############

package affx_fusion::DttArrayFileReader;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_DttArrayFileReader(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_DttArrayFileReader($self);
        delete $OWNER{$self};
    }
}

*GetFileName = *affx_fusionc::DttArrayFileReader_GetFileName;
*SetFileName = *affx_fusionc::DttArrayFileReader_SetFileName;
*Read = *affx_fusionc::DttArrayFileReader_Read;
*Exists = *affx_fusionc::DttArrayFileReader_Exists;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::FusionTagValuePairType ##############

package affx_fusion::FusionTagValuePairType;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
*swig_Tag_get = *affx_fusionc::FusionTagValuePairType_Tag_get;
*swig_Tag_set = *affx_fusionc::FusionTagValuePairType_Tag_set;
*swig_Value_get = *affx_fusionc::FusionTagValuePairType_Value_get;
*swig_Value_set = *affx_fusionc::FusionTagValuePairType_Value_set;
*FusionTagValuePairType_assign = *affx_fusionc::FusionTagValuePairType_FusionTagValuePairType_assign;
*FusionTagValuePairType_equals_obj = *affx_fusionc::FusionTagValuePairType_FusionTagValuePairType_equals_obj;
*FusionTagValuePairType_equals_tag = *affx_fusionc::FusionTagValuePairType_FusionTagValuePairType_equals_tag;
*DetailedType = *affx_fusionc::FusionTagValuePairType_DetailedType;
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_FusionTagValuePairType(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_FusionTagValuePairType($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::FusionArrayFileReader ##############

package affx_fusion::FusionArrayFileReader;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_FusionArrayFileReader(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_FusionArrayFileReader($self);
        delete $OWNER{$self};
    }
}

*Read = *affx_fusionc::FusionArrayFileReader_Read;
*DataTypeIdentifier = *affx_fusionc::FusionArrayFileReader_DataTypeIdentifier;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::FusionProbeSetResults ##############

package affx_fusion::FusionProbeSetResults;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_FusionProbeSetResults(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_FusionProbeSetResults($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::FusionExpressionProbeSetResults ##############

package affx_fusion::FusionExpressionProbeSetResults;
@ISA = qw( affx_fusion affx_fusion::FusionProbeSetResults );
%OWNER = ();
%ITERATORS = ();
*Clear = *affx_fusionc::FusionExpressionProbeSetResults_Clear;
*GetDetectionPValue = *affx_fusionc::FusionExpressionProbeSetResults_GetDetectionPValue;
*GetSignal = *affx_fusionc::FusionExpressionProbeSetResults_GetSignal;
*GetNumPairs = *affx_fusionc::FusionExpressionProbeSetResults_GetNumPairs;
*GetNumUsedPairs = *affx_fusionc::FusionExpressionProbeSetResults_GetNumUsedPairs;
*GetDetection = *affx_fusionc::FusionExpressionProbeSetResults_GetDetection;
*HasCompResults = *affx_fusionc::FusionExpressionProbeSetResults_HasCompResults;
*GetChangePValue = *affx_fusionc::FusionExpressionProbeSetResults_GetChangePValue;
*GetSignalLogRatio = *affx_fusionc::FusionExpressionProbeSetResults_GetSignalLogRatio;
*GetSignalLogRatioLow = *affx_fusionc::FusionExpressionProbeSetResults_GetSignalLogRatioLow;
*GetSignalLogRatioHigh = *affx_fusionc::FusionExpressionProbeSetResults_GetSignalLogRatioHigh;
*GetNumCommonPairs = *affx_fusionc::FusionExpressionProbeSetResults_GetNumCommonPairs;
*GetChange = *affx_fusionc::FusionExpressionProbeSetResults_GetChange;
*SetDetectionPValue = *affx_fusionc::FusionExpressionProbeSetResults_SetDetectionPValue;
*SetSignal = *affx_fusionc::FusionExpressionProbeSetResults_SetSignal;
*SetNumPairs = *affx_fusionc::FusionExpressionProbeSetResults_SetNumPairs;
*SetNumUsedPairs = *affx_fusionc::FusionExpressionProbeSetResults_SetNumUsedPairs;
*SetDetection = *affx_fusionc::FusionExpressionProbeSetResults_SetDetection;
*SetHasCompResults = *affx_fusionc::FusionExpressionProbeSetResults_SetHasCompResults;
*SetChangePValue = *affx_fusionc::FusionExpressionProbeSetResults_SetChangePValue;
*SetSignalLogRatio = *affx_fusionc::FusionExpressionProbeSetResults_SetSignalLogRatio;
*SetSignalLogRatioLow = *affx_fusionc::FusionExpressionProbeSetResults_SetSignalLogRatioLow;
*SetSignalLogRatioHigh = *affx_fusionc::FusionExpressionProbeSetResults_SetSignalLogRatioHigh;
*SetNumCommonPairs = *affx_fusionc::FusionExpressionProbeSetResults_SetNumCommonPairs;
*SetChange = *affx_fusionc::FusionExpressionProbeSetResults_SetChange;
*GetDetectionString = *affx_fusionc::FusionExpressionProbeSetResults_GetDetectionString;
*GetChangeString = *affx_fusionc::FusionExpressionProbeSetResults_GetChangeString;
*FusionExpressionProbeSetResults_assign = *affx_fusionc::FusionExpressionProbeSetResults_FusionExpressionProbeSetResults_assign;
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_FusionExpressionProbeSetResults(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_FusionExpressionProbeSetResults($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::FusionGenotypeProbeSetResults ##############

package affx_fusion::FusionGenotypeProbeSetResults;
@ISA = qw( affx_fusion affx_fusion::FusionProbeSetResults );
%OWNER = ();
%ITERATORS = ();
*Clear = *affx_fusionc::FusionGenotypeProbeSetResults_Clear;
*GetAlleleCall = *affx_fusionc::FusionGenotypeProbeSetResults_GetAlleleCall;
*GetConfidence = *affx_fusionc::FusionGenotypeProbeSetResults_GetConfidence;
*GetRAS1 = *affx_fusionc::FusionGenotypeProbeSetResults_GetRAS1;
*GetRAS2 = *affx_fusionc::FusionGenotypeProbeSetResults_GetRAS2;
*GetPValueAA = *affx_fusionc::FusionGenotypeProbeSetResults_GetPValueAA;
*GetPValueAB = *affx_fusionc::FusionGenotypeProbeSetResults_GetPValueAB;
*GetPValueBB = *affx_fusionc::FusionGenotypeProbeSetResults_GetPValueBB;
*GetPValueNoCall = *affx_fusionc::FusionGenotypeProbeSetResults_GetPValueNoCall;
*SetAlleleCall = *affx_fusionc::FusionGenotypeProbeSetResults_SetAlleleCall;
*SetConfidence = *affx_fusionc::FusionGenotypeProbeSetResults_SetConfidence;
*SetRAS1 = *affx_fusionc::FusionGenotypeProbeSetResults_SetRAS1;
*SetRAS2 = *affx_fusionc::FusionGenotypeProbeSetResults_SetRAS2;
*SetPValueAA = *affx_fusionc::FusionGenotypeProbeSetResults_SetPValueAA;
*SetPValueAB = *affx_fusionc::FusionGenotypeProbeSetResults_SetPValueAB;
*SetPValueBB = *affx_fusionc::FusionGenotypeProbeSetResults_SetPValueBB;
*SetPValueNoCall = *affx_fusionc::FusionGenotypeProbeSetResults_SetPValueNoCall;
*GetAlleleCallString = *affx_fusionc::FusionGenotypeProbeSetResults_GetAlleleCallString;
*FusionGenotypeProbeSetResults_assign = *affx_fusionc::FusionGenotypeProbeSetResults_FusionGenotypeProbeSetResults_assign;
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_FusionGenotypeProbeSetResults(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_FusionGenotypeProbeSetResults($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::FusionUniversalProbeSetResults ##############

package affx_fusion::FusionUniversalProbeSetResults;
@ISA = qw( affx_fusion affx_fusion::FusionProbeSetResults );
%OWNER = ();
%ITERATORS = ();
*GetBackground = *affx_fusionc::FusionUniversalProbeSetResults_GetBackground;
*SetBackground = *affx_fusionc::FusionUniversalProbeSetResults_SetBackground;
*Clear = *affx_fusionc::FusionUniversalProbeSetResults_Clear;
*FusionUniversalProbeSetResults_assign = *affx_fusionc::FusionUniversalProbeSetResults_FusionUniversalProbeSetResults_assign;
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_FusionUniversalProbeSetResults(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_FusionUniversalProbeSetResults($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::FusionCDFFileHeader ##############

package affx_fusion::FusionCDFFileHeader;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
*GetCols = *affx_fusionc::FusionCDFFileHeader_GetCols;
*GetRows = *affx_fusionc::FusionCDFFileHeader_GetRows;
*GetNumProbeSets = *affx_fusionc::FusionCDFFileHeader_GetNumProbeSets;
*GetNumQCProbeSets = *affx_fusionc::FusionCDFFileHeader_GetNumQCProbeSets;
*GetReference = *affx_fusionc::FusionCDFFileHeader_GetReference;
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_FusionCDFFileHeader(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_FusionCDFFileHeader($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::FusionCDFProbeInformation ##############

package affx_fusion::FusionCDFProbeInformation;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
*GetListIndex = *affx_fusionc::FusionCDFProbeInformation_GetListIndex;
*GetExpos = *affx_fusionc::FusionCDFProbeInformation_GetExpos;
*GetX = *affx_fusionc::FusionCDFProbeInformation_GetX;
*GetY = *affx_fusionc::FusionCDFProbeInformation_GetY;
*GetPBase = *affx_fusionc::FusionCDFProbeInformation_GetPBase;
*GetTBase = *affx_fusionc::FusionCDFProbeInformation_GetTBase;
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_FusionCDFProbeInformation(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_FusionCDFProbeInformation($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::FusionCDFProbeGroupInformation ##############

package affx_fusion::FusionCDFProbeGroupInformation;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
*GetDirection = *affx_fusionc::FusionCDFProbeGroupInformation_GetDirection;
*GetNumLists = *affx_fusionc::FusionCDFProbeGroupInformation_GetNumLists;
*GetNumCells = *affx_fusionc::FusionCDFProbeGroupInformation_GetNumCells;
*GetNumCellsPerList = *affx_fusionc::FusionCDFProbeGroupInformation_GetNumCellsPerList;
*GetStart = *affx_fusionc::FusionCDFProbeGroupInformation_GetStart;
*GetStop = *affx_fusionc::FusionCDFProbeGroupInformation_GetStop;
*GetName = *affx_fusionc::FusionCDFProbeGroupInformation_GetName;
*GetCell = *affx_fusionc::FusionCDFProbeGroupInformation_GetCell;
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_FusionCDFProbeGroupInformation(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_FusionCDFProbeGroupInformation($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::FusionCDFProbeSetInformation ##############

package affx_fusion::FusionCDFProbeSetInformation;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
*GetProbeSetType = *affx_fusionc::FusionCDFProbeSetInformation_GetProbeSetType;
*GetDirection = *affx_fusionc::FusionCDFProbeSetInformation_GetDirection;
*GetNumLists = *affx_fusionc::FusionCDFProbeSetInformation_GetNumLists;
*GetNumGroups = *affx_fusionc::FusionCDFProbeSetInformation_GetNumGroups;
*GetNumCells = *affx_fusionc::FusionCDFProbeSetInformation_GetNumCells;
*GetNumCellsPerList = *affx_fusionc::FusionCDFProbeSetInformation_GetNumCellsPerList;
*GetProbeSetNumber = *affx_fusionc::FusionCDFProbeSetInformation_GetProbeSetNumber;
*GetGroupInformation = *affx_fusionc::FusionCDFProbeSetInformation_GetGroupInformation;
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_FusionCDFProbeSetInformation(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_FusionCDFProbeSetInformation($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::FusionCDFQCProbeInformation ##############

package affx_fusion::FusionCDFQCProbeInformation;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_FusionCDFQCProbeInformation(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_FusionCDFQCProbeInformation($self);
        delete $OWNER{$self};
    }
}

*GetX = *affx_fusionc::FusionCDFQCProbeInformation_GetX;
*GetY = *affx_fusionc::FusionCDFQCProbeInformation_GetY;
*GetPLen = *affx_fusionc::FusionCDFQCProbeInformation_GetPLen;
*IsPerfectMatchProbe = *affx_fusionc::FusionCDFQCProbeInformation_IsPerfectMatchProbe;
*IsBackgroundProbe = *affx_fusionc::FusionCDFQCProbeInformation_IsBackgroundProbe;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::FusionCDFQCProbeSetInformation ##############

package affx_fusion::FusionCDFQCProbeSetInformation;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
*GetQCProbeSetType = *affx_fusionc::FusionCDFQCProbeSetInformation_GetQCProbeSetType;
*GetNumCells = *affx_fusionc::FusionCDFQCProbeSetInformation_GetNumCells;
*GetProbeInformation = *affx_fusionc::FusionCDFQCProbeSetInformation_GetProbeInformation;
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_FusionCDFQCProbeSetInformation(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_FusionCDFQCProbeSetInformation($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::FusionCDFData ##############

package affx_fusion::FusionCDFData;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_FusionCDFData(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_FusionCDFData($self);
        delete $OWNER{$self};
    }
}

*SetFileName = *affx_fusionc::FusionCDFData_SetFileName;
*GetFileName = *affx_fusionc::FusionCDFData_GetFileName;
*GetHeader = *affx_fusionc::FusionCDFData_GetHeader;
*GetError = *affx_fusionc::FusionCDFData_GetError;
*GetProbeSetName = *affx_fusionc::FusionCDFData_GetProbeSetName;
*GetChipType = *affx_fusionc::FusionCDFData_GetChipType;
*Read = *affx_fusionc::FusionCDFData_Read;
*ReadHeader = *affx_fusionc::FusionCDFData_ReadHeader;
*Exists = *affx_fusionc::FusionCDFData_Exists;
*Close = *affx_fusionc::FusionCDFData_Close;
*IsXDACompatibleFile = *affx_fusionc::FusionCDFData_IsXDACompatibleFile;
*IsCalvinCompatibleFile = *affx_fusionc::FusionCDFData_IsCalvinCompatibleFile;
*GetProbeSetType = *affx_fusionc::FusionCDFData_GetProbeSetType;
*GetProbeSetInformation = *affx_fusionc::FusionCDFData_GetProbeSetInformation;
*GetQCProbeSetInformation = *affx_fusionc::FusionCDFData_GetQCProbeSetInformation;
*FusionGetQCProbeSetInformation_By_Type = *affx_fusionc::FusionCDFData_FusionGetQCProbeSetInformation_By_Type;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::FusionCDFQCProbeSetNames ##############

package affx_fusion::FusionCDFQCProbeSetNames;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
*GetStaticCDFQCProbeSetName = *affx_fusionc::FusionCDFQCProbeSetNames_GetStaticCDFQCProbeSetName;
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_FusionCDFQCProbeSetNames(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_FusionCDFQCProbeSetNames($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::FusionCELData ##############

package affx_fusion::FusionCELData;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
*CEL_ALL = *affx_fusionc::FusionCELData_CEL_ALL;
*CEL_DATA = *affx_fusionc::FusionCELData_CEL_DATA;
*CEL_OUTLIER = *affx_fusionc::FusionCELData_CEL_OUTLIER;
*CEL_MASK = *affx_fusionc::FusionCELData_CEL_MASK;
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_FusionCELData(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_FusionCELData($self);
        delete $OWNER{$self};
    }
}

*SetFileName = *affx_fusionc::FusionCELData_SetFileName;
*GetFileName = *affx_fusionc::FusionCELData_GetFileName;
*SetError = *affx_fusionc::FusionCELData_SetError;
*GetError = *affx_fusionc::FusionCELData_GetError;
*GetHeaderKey = *affx_fusionc::FusionCELData_GetHeaderKey;
*GetVersion = *affx_fusionc::FusionCELData_GetVersion;
*GetCols = *affx_fusionc::FusionCELData_GetCols;
*GetRows = *affx_fusionc::FusionCELData_GetRows;
*GetNumCells = *affx_fusionc::FusionCELData_GetNumCells;
*GetHeader = *affx_fusionc::FusionCELData_GetHeader;
*GetAlg = *affx_fusionc::FusionCELData_GetAlg;
*GetParams = *affx_fusionc::FusionCELData_GetParams;
*GetAlgorithmParameter = *affx_fusionc::FusionCELData_GetAlgorithmParameter;
*GetAlgorithmParameterTag = *affx_fusionc::FusionCELData_GetAlgorithmParameterTag;
*GetNumberAlgorithmParameters = *affx_fusionc::FusionCELData_GetNumberAlgorithmParameters;
*GetAlgorithmParameters = *affx_fusionc::FusionCELData_GetAlgorithmParameters;
*GetParameters = *affx_fusionc::FusionCELData_GetParameters;
*GetChipType = *affx_fusionc::FusionCELData_GetChipType;
*GetCellMargin = *affx_fusionc::FusionCELData_GetCellMargin;
*GetNumOutliers = *affx_fusionc::FusionCELData_GetNumOutliers;
*GetNumMasked = *affx_fusionc::FusionCELData_GetNumMasked;
*IndexToX = *affx_fusionc::FusionCELData_IndexToX;
*IndexToY = *affx_fusionc::FusionCELData_IndexToY;
*XYToIndex = *affx_fusionc::FusionCELData_XYToIndex;
*GetEntry = *affx_fusionc::FusionCELData_GetEntry;
*GetIntensity = *affx_fusionc::FusionCELData_GetIntensity;
*GetStdv = *affx_fusionc::FusionCELData_GetStdv;
*GetPixels = *affx_fusionc::FusionCELData_GetPixels;
*IsMasked = *affx_fusionc::FusionCELData_IsMasked;
*IsOutlier = *affx_fusionc::FusionCELData_IsOutlier;
*Close = *affx_fusionc::FusionCELData_Close;
*GetFileSize = *affx_fusionc::FusionCELData_GetFileSize;
*Exists = *affx_fusionc::FusionCELData_Exists;
*ReadHeader = *affx_fusionc::FusionCELData_ReadHeader;
*Read = *affx_fusionc::FusionCELData_Read;
*ReadEx = *affx_fusionc::FusionCELData_ReadEx;
*GetReadState = *affx_fusionc::FusionCELData_GetReadState;
*Clear = *affx_fusionc::FusionCELData_Clear;
*SetAlgorithmName = *affx_fusionc::FusionCELData_SetAlgorithmName;
*AddAlgorithmParameter = *affx_fusionc::FusionCELData_AddAlgorithmParameter;
*SetDimensions = *affx_fusionc::FusionCELData_SetDimensions;
*SetChipType = *affx_fusionc::FusionCELData_SetChipType;
*SetMargin = *affx_fusionc::FusionCELData_SetMargin;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::FusionCELFileEntryType ##############

package affx_fusion::FusionCELFileEntryType;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
*swig_Intensity_get = *affx_fusionc::FusionCELFileEntryType_Intensity_get;
*swig_Intensity_set = *affx_fusionc::FusionCELFileEntryType_Intensity_set;
*swig_Stdv_get = *affx_fusionc::FusionCELFileEntryType_Stdv_get;
*swig_Stdv_set = *affx_fusionc::FusionCELFileEntryType_Stdv_set;
*swig_Pixels_get = *affx_fusionc::FusionCELFileEntryType_Pixels_get;
*swig_Pixels_set = *affx_fusionc::FusionCELFileEntryType_Pixels_set;
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_FusionCELFileEntryType(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_FusionCELFileEntryType($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::IFusionCELDataAdapter ##############

package affx_fusion::IFusionCELDataAdapter;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
*CanReadFile = *affx_fusionc::IFusionCELDataAdapter_CanReadFile;
*SetFileName = *affx_fusionc::IFusionCELDataAdapter_SetFileName;
*GetFileName = *affx_fusionc::IFusionCELDataAdapter_GetFileName;
*SetError = *affx_fusionc::IFusionCELDataAdapter_SetError;
*GetError = *affx_fusionc::IFusionCELDataAdapter_GetError;
*GetHeaderKey = *affx_fusionc::IFusionCELDataAdapter_GetHeaderKey;
*GetVersion = *affx_fusionc::IFusionCELDataAdapter_GetVersion;
*GetCols = *affx_fusionc::IFusionCELDataAdapter_GetCols;
*GetRows = *affx_fusionc::IFusionCELDataAdapter_GetRows;
*GetNumCells = *affx_fusionc::IFusionCELDataAdapter_GetNumCells;
*GetHeader = *affx_fusionc::IFusionCELDataAdapter_GetHeader;
*GetAlg = *affx_fusionc::IFusionCELDataAdapter_GetAlg;
*GetParams = *affx_fusionc::IFusionCELDataAdapter_GetParams;
*GetAlgorithmParameter = *affx_fusionc::IFusionCELDataAdapter_GetAlgorithmParameter;
*GetAlgorithmParameterTag = *affx_fusionc::IFusionCELDataAdapter_GetAlgorithmParameterTag;
*GetNumberAlgorithmParameters = *affx_fusionc::IFusionCELDataAdapter_GetNumberAlgorithmParameters;
*GetAlgorithmParameters = *affx_fusionc::IFusionCELDataAdapter_GetAlgorithmParameters;
*GetParameters = *affx_fusionc::IFusionCELDataAdapter_GetParameters;
*GetChipType = *affx_fusionc::IFusionCELDataAdapter_GetChipType;
*GetCellMargin = *affx_fusionc::IFusionCELDataAdapter_GetCellMargin;
*GetNumOutliers = *affx_fusionc::IFusionCELDataAdapter_GetNumOutliers;
*GetNumMasked = *affx_fusionc::IFusionCELDataAdapter_GetNumMasked;
*IndexToX = *affx_fusionc::IFusionCELDataAdapter_IndexToX;
*IndexToY = *affx_fusionc::IFusionCELDataAdapter_IndexToY;
*XYToIndex = *affx_fusionc::IFusionCELDataAdapter_XYToIndex;
*GetEntry = *affx_fusionc::IFusionCELDataAdapter_GetEntry;
*GetIntensity = *affx_fusionc::IFusionCELDataAdapter_GetIntensity;
*GetStdv = *affx_fusionc::IFusionCELDataAdapter_GetStdv;
*GetPixels = *affx_fusionc::IFusionCELDataAdapter_GetPixels;
*IsMasked = *affx_fusionc::IFusionCELDataAdapter_IsMasked;
*IsOutlier = *affx_fusionc::IFusionCELDataAdapter_IsOutlier;
*Close = *affx_fusionc::IFusionCELDataAdapter_Close;
*ReadHeader = *affx_fusionc::IFusionCELDataAdapter_ReadHeader;
*Read = *affx_fusionc::IFusionCELDataAdapter_Read;
*ReadEx = *affx_fusionc::IFusionCELDataAdapter_ReadEx;
*GetReadState = *affx_fusionc::IFusionCELDataAdapter_GetReadState;
*Clear = *affx_fusionc::IFusionCELDataAdapter_Clear;
*SetAlgorithmName = *affx_fusionc::IFusionCELDataAdapter_SetAlgorithmName;
*AddAlgorithmParameter = *affx_fusionc::IFusionCELDataAdapter_AddAlgorithmParameter;
*SetDimensions = *affx_fusionc::IFusionCELDataAdapter_SetDimensions;
*SetChipType = *affx_fusionc::IFusionCELDataAdapter_SetChipType;
*SetMargin = *affx_fusionc::IFusionCELDataAdapter_SetMargin;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_IFusionCELDataAdapter($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::IFusionCHPHeaderAdapter ##############

package affx_fusion::IFusionCHPHeaderAdapter;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
*GetCols = *affx_fusionc::IFusionCHPHeaderAdapter_GetCols;
*GetRows = *affx_fusionc::IFusionCHPHeaderAdapter_GetRows;
*GetNumProbeSets = *affx_fusionc::IFusionCHPHeaderAdapter_GetNumProbeSets;
*GetAssayType = *affx_fusionc::IFusionCHPHeaderAdapter_GetAssayType;
*GetChipType = *affx_fusionc::IFusionCHPHeaderAdapter_GetChipType;
*GetAlgName = *affx_fusionc::IFusionCHPHeaderAdapter_GetAlgName;
*GetAlgVersion = *affx_fusionc::IFusionCHPHeaderAdapter_GetAlgVersion;
*GetAlgorithmParameters = *affx_fusionc::IFusionCHPHeaderAdapter_GetAlgorithmParameters;
*GetAlgorithmParameterCount = *affx_fusionc::IFusionCHPHeaderAdapter_GetAlgorithmParameterCount;
*GetSummaryParameters = *affx_fusionc::IFusionCHPHeaderAdapter_GetSummaryParameters;
*GetParentCellFile = *affx_fusionc::IFusionCHPHeaderAdapter_GetParentCellFile;
*GetProgID = *affx_fusionc::IFusionCHPHeaderAdapter_GetProgID;
*GetAlgorithmParameter = *affx_fusionc::IFusionCHPHeaderAdapter_GetAlgorithmParameter;
*GetSummaryParameter = *affx_fusionc::IFusionCHPHeaderAdapter_GetSummaryParameter;
*GetBackgroundZoneInfo = *affx_fusionc::IFusionCHPHeaderAdapter_GetBackgroundZoneInfo;
*GetBackgroundZones = *affx_fusionc::IFusionCHPHeaderAdapter_GetBackgroundZones;
*GetBackgroundZone = *affx_fusionc::IFusionCHPHeaderAdapter_GetBackgroundZone;
*GetMagic = *affx_fusionc::IFusionCHPHeaderAdapter_GetMagic;
*GetVersion = *affx_fusionc::IFusionCHPHeaderAdapter_GetVersion;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_IFusionCHPHeaderAdapter($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::IFusionCHPDataAdapter ##############

package affx_fusion::IFusionCHPDataAdapter;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
*GetHeader = *affx_fusionc::IFusionCHPDataAdapter_GetHeader;
*CanReadFile = *affx_fusionc::IFusionCHPDataAdapter_CanReadFile;
*GetExpressionResults = *affx_fusionc::IFusionCHPDataAdapter_GetExpressionResults;
*GetGenotypingResults = *affx_fusionc::IFusionCHPDataAdapter_GetGenotypingResults;
*GetUniversalResults = *affx_fusionc::IFusionCHPDataAdapter_GetUniversalResults;
*Read = *affx_fusionc::IFusionCHPDataAdapter_Read;
*ReadHeader = *affx_fusionc::IFusionCHPDataAdapter_ReadHeader;
*SetFileName = *affx_fusionc::IFusionCHPDataAdapter_SetFileName;
*GetFileName = *affx_fusionc::IFusionCHPDataAdapter_GetFileName;
*Clear = *affx_fusionc::IFusionCHPDataAdapter_Clear;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_IFusionCHPDataAdapter($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::FusionCHPHeader ##############

package affx_fusion::FusionCHPHeader;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_FusionCHPHeader(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_FusionCHPHeader($self);
        delete $OWNER{$self};
    }
}

*GetCols = *affx_fusionc::FusionCHPHeader_GetCols;
*GetRows = *affx_fusionc::FusionCHPHeader_GetRows;
*GetNumProbeSets = *affx_fusionc::FusionCHPHeader_GetNumProbeSets;
*GetAssayType = *affx_fusionc::FusionCHPHeader_GetAssayType;
*GetChipType = *affx_fusionc::FusionCHPHeader_GetChipType;
*GetAlgName = *affx_fusionc::FusionCHPHeader_GetAlgName;
*GetAlgVersion = *affx_fusionc::FusionCHPHeader_GetAlgVersion;
*AlgorithmParameters = *affx_fusionc::FusionCHPHeader_AlgorithmParameters;
*AlgorithmParameterCount = *affx_fusionc::FusionCHPHeader_AlgorithmParameterCount;
*SummaryParameters = *affx_fusionc::FusionCHPHeader_SummaryParameters;
*GetParentCellFile = *affx_fusionc::FusionCHPHeader_GetParentCellFile;
*GetProgID = *affx_fusionc::FusionCHPHeader_GetProgID;
*GetAlgorithmParameter = *affx_fusionc::FusionCHPHeader_GetAlgorithmParameter;
*GetSummaryParameter = *affx_fusionc::FusionCHPHeader_GetSummaryParameter;
*GetBackgroundZoneInfo = *affx_fusionc::FusionCHPHeader_GetBackgroundZoneInfo;
*GetBackgroundZones = *affx_fusionc::FusionCHPHeader_GetBackgroundZones;
*GetBackgroundZone = *affx_fusionc::FusionCHPHeader_GetBackgroundZone;
*GetMagic = *affx_fusionc::FusionCHPHeader_GetMagic;
*GetVersion = *affx_fusionc::FusionCHPHeader_GetVersion;
*CheckAdapter = *affx_fusionc::FusionCHPHeader_CheckAdapter;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : affx_fusion::FusionCHPData ##############

package affx_fusion::FusionCHPData;
@ISA = qw( affx_fusion );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = affx_fusionc::new_FusionCHPData(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        affx_fusionc::delete_FusionCHPData($self);
        delete $OWNER{$self};
    }
}

*GetExpressionResults = *affx_fusionc::FusionCHPData_GetExpressionResults;
*GetGenotypingResults = *affx_fusionc::FusionCHPData_GetGenotypingResults;
*GetUniversalResults = *affx_fusionc::FusionCHPData_GetUniversalResults;
*Read = *affx_fusionc::FusionCHPData_Read;
*ReadHeader = *affx_fusionc::FusionCHPData_ReadHeader;
*Exists = *affx_fusionc::FusionCHPData_Exists;
*SetFileName = *affx_fusionc::FusionCHPData_SetFileName;
*GetFileName = *affx_fusionc::FusionCHPData_GetFileName;
*Clear = *affx_fusionc::FusionCHPData_Clear;
*CheckAdapter = *affx_fusionc::FusionCHPData_CheckAdapter;
*CreateAdapter = *affx_fusionc::FusionCHPData_CreateAdapter;
*DeleteAdapter = *affx_fusionc::FusionCHPData_DeleteAdapter;
*GetHeader = *affx_fusionc::FusionCHPData_GetHeader;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package affx_fusion;

*UpperLeft = *affx_fusionc::UpperLeft;
*UpperRight = *affx_fusionc::UpperRight;
*LowerRight = *affx_fusionc::LowerRight;
*LowerLeft = *affx_fusionc::LowerLeft;
*PARAMETER_VALUE_SIGNED_INTEGRAL = *affx_fusionc::PARAMETER_VALUE_SIGNED_INTEGRAL;
*PARAMETER_VALUE_UNSIGNED_INTEGRAL = *affx_fusionc::PARAMETER_VALUE_UNSIGNED_INTEGRAL;
*PARAMETER_VALUE_FLOATING_POINT = *affx_fusionc::PARAMETER_VALUE_FLOATING_POINT;
*PARAMETER_VALUE_STRING8_TYPE = *affx_fusionc::PARAMETER_VALUE_STRING8_TYPE;
*PARAMETER_VALUE_STRING16_TYPE = *affx_fusionc::PARAMETER_VALUE_STRING16_TYPE;
*AFFY_EXPR_PS = *affx_fusionc::AFFY_EXPR_PS;
*AFFY_GENO_PS = *affx_fusionc::AFFY_GENO_PS;
*AFFY_TAG_PS = *affx_fusionc::AFFY_TAG_PS;
*AFFY_RESEQ_PS = *affx_fusionc::AFFY_RESEQ_PS;
*AFFY_CNTRL_PS = *affx_fusionc::AFFY_CNTRL_PS;
*ARRAY_FILE_CREATEION_ACTION = *affx_fusionc::ARRAY_FILE_CREATEION_ACTION;
*ARRAY_FILE_ATTRIBUTE_UPDATE_ACTION = *affx_fusionc::ARRAY_FILE_ATTRIBUTE_UPDATE_ACTION;
*FLUIDICS_INSTRUMENT_CONTROL_ACTION = *affx_fusionc::FLUIDICS_INSTRUMENT_CONTROL_ACTION;
*SCAN_INSTRUMENT_CONTROL_ACTION = *affx_fusionc::SCAN_INSTRUMENT_CONTROL_ACTION;
*ARRAY_FILE_TYPE_IDENTIFIER = *affx_fusionc::ARRAY_FILE_TYPE_IDENTIFIER;
*MAX_CDF_PROBE_SET_NAME_LENGTH = *affx_fusionc::MAX_CDF_PROBE_SET_NAME_LENGTH;
*ByteColType = *affx_fusionc::ByteColType;
*UByteColType = *affx_fusionc::UByteColType;
*ShortColType = *affx_fusionc::ShortColType;
*UShortColType = *affx_fusionc::UShortColType;
*IntColType = *affx_fusionc::IntColType;
*UIntColType = *affx_fusionc::UIntColType;
*FloatColType = *affx_fusionc::FloatColType;
*ASCIICharColType = *affx_fusionc::ASCIICharColType;
*UnicodeCharColType = *affx_fusionc::UnicodeCharColType;
*MAGIC_NUM = *affx_fusionc::MAGIC_NUM;
*VERSION = *affx_fusionc::VERSION;
*SCAN_ACQUISITION_DATA_TYPE = *affx_fusionc::SCAN_ACQUISITION_DATA_TYPE;
*INTENSITY_DATA_TYPE = *affx_fusionc::INTENSITY_DATA_TYPE;
*EXPRESSION_RESULTS_DATA_TYPE = *affx_fusionc::EXPRESSION_RESULTS_DATA_TYPE;
*GENOTYPING_RESULTS_DATA_TYPE = *affx_fusionc::GENOTYPING_RESULTS_DATA_TYPE;
*RESEQUENCING_RESULTS_DATA_TYPE = *affx_fusionc::RESEQUENCING_RESULTS_DATA_TYPE;
*TAG_RESULTS_DATA_TYPE = *affx_fusionc::TAG_RESULTS_DATA_TYPE;
*Expression = *affx_fusionc::Expression;
*Genotyping = *affx_fusionc::Genotyping;
*Tag = *affx_fusionc::Tag;
*Resequencing = *affx_fusionc::Resequencing;
*Control = *affx_fusionc::Control;
*ProbeNoDirection = *affx_fusionc::ProbeNoDirection;
*ProbeSenseDirection = *affx_fusionc::ProbeSenseDirection;
*ProbeAntiSenseDirection = *affx_fusionc::ProbeAntiSenseDirection;
*AUDIT_USER_TAG = *affx_fusionc::AUDIT_USER_TAG;
*AUDIT_DATE_TAG = *affx_fusionc::AUDIT_DATE_TAG;
*AUDIT_TIME_TAG = *affx_fusionc::AUDIT_TIME_TAG;
*AUDIT_ACTION_TAG = *affx_fusionc::AUDIT_ACTION_TAG;
*AUDIT_ARRAY_ID_TAG = *affx_fusionc::AUDIT_ARRAY_ID_TAG;
*AUDIT_INPUT_ID_TAG = *affx_fusionc::AUDIT_INPUT_ID_TAG;
*AUDIT_OUTPUT_ID_TAG = *affx_fusionc::AUDIT_OUTPUT_ID_TAG;
*AUDIT_START_TAG = *affx_fusionc::AUDIT_START_TAG;
*AUDIT_END_TAG = *affx_fusionc::AUDIT_END_TAG;
*GRD_FILE_TYPE_IDENTIFIER = *affx_fusionc::GRD_FILE_TYPE_IDENTIFIER;
*TEMPLATE_FILE_CREATEION_ACTION = *affx_fusionc::TEMPLATE_FILE_CREATEION_ACTION;
*TEMPLATE_FILE_ATTRIBUTE_UPDATE_ACTION = *affx_fusionc::TEMPLATE_FILE_ATTRIBUTE_UPDATE_ACTION;
*TEMPLATE_FILE_TYPE_IDENTIFIER = *affx_fusionc::TEMPLATE_FILE_TYPE_IDENTIFIER;
*_AFFY_BASE_TYPE_H = *affx_fusionc::_AFFY_BASE_TYPE_H;
*__int8_t_defined = *affx_fusionc::__int8_t_defined;
*AFFX_FILEIO_H = *affx_fusionc::AFFX_FILEIO_H;
*MAX_PROBE_SET_NAME_LENGTH = *affx_fusionc::MAX_PROBE_SET_NAME_LENGTH;
*UnknownProbeSetType = *affx_fusionc::UnknownProbeSetType;
*ExpressionProbeSetType = *affx_fusionc::ExpressionProbeSetType;
*GenotypingProbeSetType = *affx_fusionc::GenotypingProbeSetType;
*ResequencingProbeSetType = *affx_fusionc::ResequencingProbeSetType;
*TagProbeSetType = *affx_fusionc::TagProbeSetType;
*NoDirection = *affx_fusionc::NoDirection;
*SenseDirection = *affx_fusionc::SenseDirection;
*AntiSenseDirection = *affx_fusionc::AntiSenseDirection;
*PROBE_SIZE = *affx_fusionc::PROBE_SIZE;
*PROBE_GROUP_SIZE = *affx_fusionc::PROBE_GROUP_SIZE;
*PROBE_SET_SIZE = *affx_fusionc::PROBE_SET_SIZE;
*QC_PROBE_SIZE = *affx_fusionc::QC_PROBE_SIZE;
*UnknownQCProbeSetType = *affx_fusionc::UnknownQCProbeSetType;
*CheckerboardNegativeQCProbeSetType = *affx_fusionc::CheckerboardNegativeQCProbeSetType;
*CheckerboardPositiveQCProbeSetType = *affx_fusionc::CheckerboardPositiveQCProbeSetType;
*HybNegativeQCProbeSetType = *affx_fusionc::HybNegativeQCProbeSetType;
*HybPositiveQCProbeSetType = *affx_fusionc::HybPositiveQCProbeSetType;
*TextFeaturesNegativeQCProbeSetType = *affx_fusionc::TextFeaturesNegativeQCProbeSetType;
*TextFeaturesPositiveQCProbeSetType = *affx_fusionc::TextFeaturesPositiveQCProbeSetType;
*CentralNegativeQCProbeSetType = *affx_fusionc::CentralNegativeQCProbeSetType;
*CentralPositiveQCProbeSetType = *affx_fusionc::CentralPositiveQCProbeSetType;
*GeneExpNegativeQCProbeSetType = *affx_fusionc::GeneExpNegativeQCProbeSetType;
*GeneExpPositiveQCProbeSetType = *affx_fusionc::GeneExpPositiveQCProbeSetType;
*CycleFidelityNegativeQCProbeSetType = *affx_fusionc::CycleFidelityNegativeQCProbeSetType;
*CycleFidelityPositiveQCProbeSetType = *affx_fusionc::CycleFidelityPositiveQCProbeSetType;
*CentralCrossNegativeQCProbeSetType = *affx_fusionc::CentralCrossNegativeQCProbeSetType;
*CentralCrossPositiveQCProbeSetType = *affx_fusionc::CentralCrossPositiveQCProbeSetType;
*CrossHybNegativeQCProbeSetType = *affx_fusionc::CrossHybNegativeQCProbeSetType;
*CrossHybPositiveQCProbeSetType = *affx_fusionc::CrossHybPositiveQCProbeSetType;
*SpatialNormalizationNegativeQCProbeSetType = *affx_fusionc::SpatialNormalizationNegativeQCProbeSetType;
*SpatialNormalizationPositiveQCProbeSetType = *affx_fusionc::SpatialNormalizationPositiveQCProbeSetType;
*QC_PROBE_SET_SIZE = *affx_fusionc::QC_PROBE_SET_SIZE;
*ABS_PRESENT_CALL = *affx_fusionc::ABS_PRESENT_CALL;
*ABS_MARGINAL_CALL = *affx_fusionc::ABS_MARGINAL_CALL;
*ABS_ABSENT_CALL = *affx_fusionc::ABS_ABSENT_CALL;
*ABS_NO_CALL = *affx_fusionc::ABS_NO_CALL;
*COMP_INCREASE_CALL = *affx_fusionc::COMP_INCREASE_CALL;
*COMP_DECREASE_CALL = *affx_fusionc::COMP_DECREASE_CALL;
*COMP_MOD_INCREASE_CALL = *affx_fusionc::COMP_MOD_INCREASE_CALL;
*COMP_MOD_DECREASE_CALL = *affx_fusionc::COMP_MOD_DECREASE_CALL;
*COMP_NO_CHANGE_CALL = *affx_fusionc::COMP_NO_CHANGE_CALL;
*COMP_NO_CALL = *affx_fusionc::COMP_NO_CALL;
*ALLELE_A_CALL = *affx_fusionc::ALLELE_A_CALL;
*ALLELE_B_CALL = *affx_fusionc::ALLELE_B_CALL;
*ALLELE_AB_CALL = *affx_fusionc::ALLELE_AB_CALL;
*ALLELE_NO_CALL = *affx_fusionc::ALLELE_NO_CALL;
*NO_SIGNAL_THR_FORCE_CALL = *affx_fusionc::NO_SIGNAL_THR_FORCE_CALL;
*WEAK_SIGNAL_THR_FORCE_CALL = *affx_fusionc::WEAK_SIGNAL_THR_FORCE_CALL;
*SATURATION_LEVEL_FORCE_CALL = *affx_fusionc::SATURATION_LEVEL_FORCE_CALL;
*QUALITY_SCORE_THR_FORCE_CALL = *affx_fusionc::QUALITY_SCORE_THR_FORCE_CALL;
*TRACE_AND_SEQUENCE_PROFILES_FORCE_CALL = *affx_fusionc::TRACE_AND_SEQUENCE_PROFILES_FORCE_CALL;
*RELIABILITY_THR_FORCE_CALL = *affx_fusionc::RELIABILITY_THR_FORCE_CALL;
*BAR_DATA_DOUBLE = *affx_fusionc::BAR_DATA_DOUBLE;
*BAR_DATA_FLOAT = *affx_fusionc::BAR_DATA_FLOAT;
*BAR_DATA_INTEGER = *affx_fusionc::BAR_DATA_INTEGER;
*BAR_DATA_SHORT = *affx_fusionc::BAR_DATA_SHORT;
*BAR_DATA_CHAR = *affx_fusionc::BAR_DATA_CHAR;
*BAR_DATA_UINTEGER = *affx_fusionc::BAR_DATA_UINTEGER;
*BAR_DATA_USHORT = *affx_fusionc::BAR_DATA_USHORT;
*BAR_DATA_UCHAR = *affx_fusionc::BAR_DATA_UCHAR;
*BPMAP_FILE_HEADER_BYTES = *affx_fusionc::BPMAP_FILE_HEADER_BYTES;
*BPMAP_FILE_HEADER_LEN = *affx_fusionc::BPMAP_FILE_HEADER_LEN;
*PM_ONLY = *affx_fusionc::PM_ONLY;
*PM_MM = *affx_fusionc::PM_MM;
*PROBE_STORAGE_BUFFER_LENGTH = *affx_fusionc::PROBE_STORAGE_BUFFER_LENGTH;
*HIT_ITEM_SIZE_WITH_PROBE_PAIRS = *affx_fusionc::HIT_ITEM_SIZE_WITH_PROBE_PAIRS;
*HIT_ITEM_SIZE_WITH_PM_ONLY = *affx_fusionc::HIT_ITEM_SIZE_WITH_PM_ONLY;
*GRC_VERSION = *affx_fusionc::GRC_VERSION;
*GRC_MAGIC = *affx_fusionc::GRC_MAGIC;
*GCOS_SAMPLE_NAME_PARAMETER_NAME = *affx_fusionc::GCOS_SAMPLE_NAME_PARAMETER_NAME;
*GCOS_SAMPLE_TYPE_PARAMETER_NAME = *affx_fusionc::GCOS_SAMPLE_TYPE_PARAMETER_NAME;
*GCOS_SAMPLE_PROJECT_PARAMETER_NAME = *affx_fusionc::GCOS_SAMPLE_PROJECT_PARAMETER_NAME;
*FusionExpression = *affx_fusionc::FusionExpression;
*FusionGenotyping = *affx_fusionc::FusionGenotyping;
*FusionResequencing = *affx_fusionc::FusionResequencing;
*FusionUniversal = *affx_fusionc::FusionUniversal;
*FusionUnknown = *affx_fusionc::FusionUnknown;
1;
